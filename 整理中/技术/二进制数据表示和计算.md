## 二进制数据表示和计算

在计算机中，进行二进制的加法很简单，因为符合冯诺依曼架构的计算机都有加法运算器。

但是如果要进行减法运算就很难，因为没有减法运算器，所以计算机中就将减法（a-b）转换为加负数的形式运算（a+ (-b)）。为了实现这种转换，出现了码制的概念。

* 原码：一个数，当我们按照进制转换将其转换为二进制后，得到的二进制表示形式就是它的原码，例如，将十进制数1转换为8位二进制数就是 `0000 0001`，这就是十进制数1的二进制原码；

* 符号位： 那么-1又如何表示呢？ 我们可以将其看做 【负号+ 1】，而1表示为`0000 0001`，现在又只有8个位置可供存储，负号怎么表示和存储为二进制呢？ 针对这个问题，引入了符号位，规定了最高位用来存储正负符号，如果是负，最高位就是1，如果是正，最高位就是0。那么`-1`就可以表示为 `1000 0001`。 

* 有符号数与无符号数： 引入符号位产生一个副作用，就是原本8个二进制位可以表示的范围为 0 ~ 2<sup>8</sup> （即 0 ~ 255）【此时为无符号数】, 将最高位作为符号位后，8个二进制位表示的范围就变成了 -（2<sup>8-1</sup> -1） ~ + （2<sup>8-1 </sup> -1） (即 -128-127)，【此时称为有符号数】

* 现在，我们可以使用原码分别表示`1`和`-1`了，是不是就可以用`a + (-b)`的方法做减法运算了呢，我们试一下：` 1-1 = 1 +  (-1) = 0000 0001 + 1000 0001 = 10000010 `，结果最高位为1，代表负号，后面的七位`000 0010` 转换为十进制是 2， 结果是 -2。

* 反码：计算机科学家很生气，`1-1 = -2` 就很离谱。所以他们又发明了反码，规定：

  * 如果一个数是正数，那么其反码和源码一样，如 1 的反码也是`0000 0001`
  * 如果一个数是负数，那么其反码就是 原码除符号位不变外，其余位按位取反（取反的意思是1变0,0变1），比如 -1 的原码是`1 000 0001` ，其反码就是`1 111 1110`;

* 我们再来用反码做上面那个减法： `1 -1 = 1 + (-1) = 0000 0001 + 1111 1110 = 11111111`，现在得到的结果 `1 1111111` 是反码，我们要得到它的十进制结果，还是要把它还原为原码，就是按照原码转反码的规则再转一次：`1 000 0000` ，最高位是1，代表负号。后面七位转换为十进制是0。于是我们得到了 ` 1 - 1 = -0`.

* 现在是不是就万事大吉了呢？并不是，我们再看另一个例子：`-1 - 3 = (-1) + (-3) = 1 111 1110 + 1 111 1100 = 1 1111 1010 `，还原为原码 `1 000 0101`，转换为十进制为 - 5.

* 补码： 计算机科学家又生气了，这个反码解决了相反数之和不为0的问题，却并没有解决其它数相减的结果不准确问题，于是他们又引入了补码，规定：

  * 如果一个数是正数，那么该数的补码等于其原码，如 1 的补码为 `0000 0001`
  * 如果一个数是负数，那么该数的补码等于反码 +1， 如 -1 的反码为 `1 111 1110`，+1后，其补码为 `1111 1111`

* 现在再用补码试试上面的减法计算： `-1 - 3 = (-1) + (-3) = 1111 1111 + 1111 1101 = 1111 1100`，我们得到的`1111 1100` 是补码并且是负数，要转为十进制，先 -1 还原为反码，变为 `1 1111 1011`,  然后取反还原为原码得到：`1 0000 0100`，转换为十进制为`-4`。 如此，就真的是万事大吉了。

* 所以，在计算机中，所有的加减法都是用补码进行计算的。

* 以上，我们说的都是整数之间的运算，那么遇到小数该怎么办呢，比如 `123.456`怎么用二进制表示和运算？

* 首先，如何表示小数？这是个问题。计算机科学家把小数叫做浮点数，对于浮点数，有一个表示公示：N = M * R<sup>e</sup>

  * 其中，左边的N就是要表示的浮点数，而右边就是一个统一表达式
  * M 是尾数，表示一个固定格式的数字，它的格式被规定为：正数部分只有各位，并且个位是1。位数所占用的二进制位数决定了数值的精度。例如在32位浮点数中，尾数位数为23位，而精度更高的64位浮点数中，尾数部分的位数为52位
  * R为基数，表示是R进制，如果是十进制，R就是10，如果是二进制，R就是2；
  * e为指数，也叫阶码，它的位数决定了数值的表示范围，比如在32位精度的浮点数中，它的位数是8位，在更高精度的64位精度浮点数中，它的位数是11位。
  * 例如`123.456` 这个数，
    * 表示为十进制浮点数形式就是 `1.23456` * 10<sup>2</sup>，其中：
      * 尾数M 为 1.23456；
      * 基数R为10
      * 指数e位2
    * 如果它转换为二进制，为`1111011.011101001`，将它表示为32位浮点数就是`1.111011011101001` * 2<sup>6</sup>，其中：
      * 尾数M为`1.111011011101001`
      * 基数R为2,
      * 指数e为6

* 现在小数（浮点数）可以表示出来了，那么如何运算呢？有两种方式：

  * 第一种，将浮点数转换为二进制浮点数，然后转为对应的二进制存储方式计算，计算后再逆向转换回十进制浮点数【转换为二进制存储方式比较复杂，具体参见[[二进制遇上浮点数]]一文】

  * 第二种，直接拿浮点数进行计算。比如 `12.12 - 3.434` 的转换和计算过程为：

    * 0. 转换
         1. `12.12` 转换为二进制小数为：`1100.000111101011`，转换为浮点表达式为： `1.100000111101011` * 2<sup>3</sup>
         2. `-3.434` 转换为二进制小数为：`-11.011011110001101`，转换为浮点表达式为：`-1.1011011110001101` * 2<sup>1</sup>

    * 1. 对阶。

         由于上面转换后，参与计算的两个数的浮点表达式中的指数（阶码）是不一样的，不可以直接计算，需要先将两个数阶码变为一致，都变为较大的那个指数，这里就需要将`-3.434`的指数变为3，变为：

         `-0.011011011110001101` * 2<sup>3</sup>

    * 2. 尾数计算

         

         

         

    * 3. 规格化