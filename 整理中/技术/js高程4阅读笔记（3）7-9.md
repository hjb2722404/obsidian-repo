## 7. 迭代器与生成器

* 在软件开发领域，“迭代” 的意思是按照顺序反复多次执行一段程序，通常会有明确的终止条件

### 理解迭代

* 迭代会在一个有序集合上进行。
* 数组循环式迭代的缺点：
	* 迭代前需要实现知道如何使用数据结构
	* 遍历顺序并不是数据结构固有的

### 迭代器模式

* 可迭代对象
	* 元素有限
	* 无歧义的遍历顺序
* 迭代器是按需创建的一次性对象，每个迭代器都会关联一个可迭代对象
* 迭代器无需了解与其关联的对象的结构，只需要知道如何取得连续的值
* 具有迭代器的类型都具有`Symbol.iterator`属性，通过这个属性拿到该类型的迭代器
* ES中具有迭代器的数据类型
	* 字符串
	* 数组
	* 映射
	* 集合
	* `arguments`对象
	* `NodeList`等DOM集合类型
* 接收可迭代对象的原生语言特性
	* `for-of` 循环
	* 数组解构
	* 扩展符操作
	* `Array.from()`
	* 创建集合
	* 创建映射
	* `Promise.all()`
	* `Promise.race()`
	* `yield* ` 操作符
* 迭代器是一种一次性使用的对象，用于迭代与其关联的可迭代对象。
* 迭代器API使用`next()`方法在可迭代对象中遍历数据
* `next()`方法返回的对象包含两个属性：
	* `done`: 布尔值，表示是否还可以再次调用`next()`取得下一个值
	* `value`  包含可迭代对象的下一个值
* 迭代器并不与可迭代对象某个时刻的快照绑定，而仅仅是使用游标来记录遍历可迭代对象的历程。 如果可迭代对象在迭代期间被修改了，那么迭代器也会反映相应的变化
* 迭代器维护着一个指向可迭代对象的引用，因此迭代器会阻止垃圾回收程序回收可 迭代对象
* 任何实现 Iterator 接口的对象都可以作为迭代器使用
* 可选的 return()方法用于指定在迭代器提前关闭时执行的逻辑
	* for-of 循环通过 break、continue、return 或 throw 提前退出；
	* 解构操作并未消费所有值
	* 数组的迭代器就是不能关 闭的
	* 要知道某个迭代器是否可关闭， 可以测试这个迭代器实例的 return 属性是不是函数对象

### 生成器

* 生成器是 `ECMAScript 6` 新增的一个极为灵活的结构，拥有在一个函数块内暂停和恢复代码执行的 能力
* 生成器的形式是一个函数，函数名称前面加一个星号（*）表示它是一个生成器
* 箭头函数不能用来定义生成器函数
* 标识生成器函数的星号不受两侧空格的影响
* 调用生成器函数会产生一个生成器对象。
* 生成器具有 `next()`方法。调用这个方法会让生成器 开始或恢复执行
* 生成器函数只会在初次调用 `next()`方法后开始执行
* `yield` 关键字可以让生成器停止和开始执行
* 生成器函数内部的执行流程会针对每个生成器对象区分作用域。在一个生成器对象上调用 `next()` 不会影响其他生成器
* `yield` 关键字只能在生成器函数内部使用
* 一个可选的 `return()`方法用于提前终止迭代器
* 生成器对象除了有这两个方法(`next`,`return`)，还有第三 个方法：`throw()`。
* `return()`和 `throw()`方法都可以用于强制生成器进入关闭状态。
* `throw()`方法会在暂停的时候将一个提供的错误注入到生成器对象中。如果错误未被处理，生成器 就会关闭

## 8. 对象、类与面向对象编程

### 理解对象

* 对象就是一组没有特定顺序的 值
* 对象的数据属性
	* `[[Configurable]] `
		* 是否可通过`delete`删除并重新定义
		* 是否可以修改它的特性
		* 是否可以把它改为访问器属性
		* 默认都是`true`
	* `[[Enumerable]]`表示是否可通过`for-in`循环返回，默认为`true`
	* `[[Writable]]` 标识属性的值是否可以被修改，默认为`true`
	* `[[Value]]` 包含属性实际的值。 默认值为`undefined`
	* 要修改属性的默认特性，就必须使用 `Object.defineProperty()`方法，有三个参数
		* 要给其添加属性的对象
		* 属性的名称
		* 一个描述符对象，描述符对象上的属性可以包 含：`configurable`、`enumerable`、`writable` 和 `value`，跟相关特性的名称一一对应。根据要修改 的特性，可以设置其中一个或多个值。
		* 在调用 `Object.defineProperty()`时，`configurable`、`enumerable` 和 `writable` 的值如果不 指定，则都默认为 `false`。【？？验证不对，待研究】
	* 对象的访问器属性
		* `[[Configurable]]` 同数据属性同名属性
		* `[[Enumerable]] ` 同数据属性同名属性
		* `[[Get]] ` 获取函数，在读取属性时调用，默认值为`undefined`
		* `[[Set]] `设置函数， 在写入属性时调用， 默认值为 `undefined`
		* 访问器属性是不能直接定义的，必须使用 `Object.defineProperty()`
		* `Object.defineProperties()`方法可以通过多个描述符一次性定义多个属性。
	* 使用 `Object.getOwnPropertyDescriptor()`方法可以取得指定属性的属性描述符
	* `Object.assign()`方法接收一个目标对象和一个 或多个源对象作为参数，然后将每个源对象中可枚举和自有属性复制到目标对象。对每个符合条件的属性，这个方法会使用源对象上的`[[Get]]`取得属性的值，然后使用目标 对象上的`[[Set]]`设置属性的值
	* `Object.assign()`实际上对每个源对象执行的是浅复制。如果多个源对象都有相同的属性，则使 用最后一个复制的值
	* `Object.assign()`没有“回滚”之前 赋值的概念，因此它是一个尽力而为、可能只会完成部分复制的方法。
	* `Object.is()`，这个方法与`===`很像，但同时也考虑到了边界情形
	* 简写属性名只要使用变量名（不用再写冒号）就会自动被解释为同 名的属性键
	* 可计算属性，可以在对象字面量中完成动态属性赋值
	* 简写方法名与可计算属性键相互兼容
	* 对象解构就是使用与对象匹配的结构来实现对象属性赋值
	* `null` 和 `undefined` 不能被解构，否则会抛出错误
	* 如果是给事先声明的变量赋值，则赋值表达式 必须包含在一对括号中
	* 解构赋值可以使用嵌套结构，以匹配嵌套的属性，但在外层属性没有定义的情况下不能使用嵌套解构
	* 如果一个解构表达式涉及 多个赋值，开始的赋值成功而后面的赋值出错，则整个解构赋值只会完成一部分
	* 在函数参数列表中也可以进行解构赋值