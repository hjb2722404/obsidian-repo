# js高程4阅读笔记（2）4-6

[TOC]

## 4. 变量、作用域与内存

* 保存原始值的变量是按值（byvalue）访问的，因为我们操作的就是存储在变量中的实际值
* JavaScript不允许直接访问内存位置，因此也就不能直接操作对象所在的内存空间
* 保存引用值的变量是按引用（by reference）访问的
* 尝试给原始值添加属性不会报错
* 在通过变量把一个原始值赋值到另一个变量时，原始值会被复制到新变量的位置
* 在把引用值从一个变量赋给另一个变量时复制的值实际上是一个指针
* 所有函数的参数都是按值传递的,如果是原始值，那么就跟原始值变量的复制一样，如果是
  引用值，那么就跟引用值变量的复制一样
* typeof 虽然对原始值很有用，但它对引用值的用处不大
* let 和 const 的顶级声明不会定义在全局上下文中，但在作用域链解析上效果是一样的。
* 函数参数被认为是当前上下文中的变量。
* 访问局部变量比访问全局变量要快，因为不用切换作用域
* 解除对一个值的引用并不会自动导致相关内存被回收。解除引用的关键在于确保相关的值已经不在上下文里了,因此它在下次垃圾回收时会被回收
* 使用const和let声明变量可能会更早地让垃圾回收程序介入。
* 利用V8的隐藏类，定义对象时尽量早地一次性声明所有属性，避免动态属性赋值，可以保证多个实例共享一个隐藏类。同理，将不想要的属性设置为null而不是delete删除，可以保持隐藏类继续共享，同时也能达到删除引用值供垃圾回收程序回收的效果。
* 内存泄露的三种情形
  * 全局变量
  * 定时器引用外部变量
  * 闭包
* 使用对象池可以避免垃圾回收程序频繁运行带来的性能损耗。

## 5. 基本引用类型

* Date 类型将日期保存为自协调世界时（UTC，Universal Time Coordinated）时间 1970 年 1 月 1 日午夜（零时）至今所经过的毫秒数
*  Date 类型可以精确表示 1970 年 1 月 1 日之前及之后 285 616 年的日期
* Date.parse() 方法接收一个表示日期的字符串参数，尝试将这个字符串转换为表示该日期的毫秒数
* Date.UTC() 方法也返回日期的毫秒表示，参数是年、零起点月数（1 月是 0，2 月是 1，以此类推）、日（1~31）、时（0~23）、分、秒和毫秒。这些参数中，只有前两个（年和月）是必需的
* Date 类型的 valueOf() 方法根本就不返回字符串，这个方法被重写后返回的是日期的毫秒表示
* 正则表达式的 valueOf() 方法返回正则表达式本身
* 正则表达式实例的属性
  * global：布尔值，标识是否设置了g标记
  * ignoreCase:：布尔值，表示是否设置了i标记
  * unicode：布尔值，表示是否设置了u标记
  * sticky：布尔值，表示是否设置了y标记
  * lastIndex： 整数，表示在源字符串中下一次搜索的开始位置，失踪从0开始
  * multiline： 布尔值，表示是否设置了m标记
  * dotAll：布尔值，表示是否设置了s标记
  * source：正则表达式的字面量字符串。没有开头和结尾的斜杠
  * flags： 正则表达式的标记字符串
* 正则表达式构造函数属性
  * input（$_）: 最后搜索的字符串
  * lastMatch（$&）：最后匹配的文本
  * lastParen（$+）：最后匹配的捕获组
  * leftContext（$`）：input字符串中出现在lastMatch前面的文本
  * rightContext（$'）：input字符串中出现在lastMatch 后面的文本
  * RegExp 构造函数的所有属性都没有任何 Web 标准出处，因此不要在生产环境中使用它们
* 引用类型与原始值包装类型的主要区别在于对象的生命周期。在通过 new 实例化引用类型后，得到的实例会在离开作用域时被销毁，而自动创建的原始值包装对象则只存在于访问它的那行代码执行期间。这意味着不能在运行时给原始值添加属性和方法
*  Object 构造函数作为一个工厂方法，能够根据传入值的类型返回相应原始值包装类型的实例。
*  使用 new 调用原始值包装类型的构造函数，与调用同名的转型函数并不一样
* Numer
  *  toString方法可传入标识基数的参数（进制）
  *  toFixed方法可传入小数位数（四舍五入）
  *  toExponential方法指定科学计数法位数
  *  toPrecision方法返回指定总位数的数字字符串
  *  isInteger判断是否为整数
  *  isSafeInteger判断是否为安全整数
* String
  * 字符串的length计算字符数量，双字节也会按照单字节计算
  * charCodeAt 默认返回的是10进制码元编码，有必要转换为16进制的才能与UTF-16编码相符
  * fromCharCode既可以接受16进制编码也可以接受10进制编码
  * 对于U+0000~U+FFFF的字符集，在Unicode中成为【基本多语言平面】(BMP)，为了表示更多字符，Unicode 将每个字符使用另外16位去选择一个【增补平面】,这种策略称为【代理对】
  * 为正确解析既包含单码元字符又包含代理对字符的字符串，可以使用 codePointAt() 来代替charCodeAt()，如果传入的码元索引并非代理对的开头，就会返回错误的码点（可采用字符串迭代的方式获得正确的码点）； fromCharCode() 也有一个对应的 fromCodePoint() 。这个方法接收任意数量的码点，返回对应字符拼接起来的字符串。
  * 由于某些Unicode字符可以有多种编码方式，为了解决同形不同码的字符之间的比较问题，可以应用normalizi方法将字符规范化（NFD、NFC、NFKD、NFKC）之后再比较。
  * 字符长度补全：padStart()与 padEnd()
*  encodeURI() 不会编码属于 URL 组件的特殊字符，比如冒号、斜杠、问号、井号，而 encodeURIComponent() 会编码它发现的所有非标准字符

## 6. 集合引用类型
### Object
* 虽然Object的实例没有多少功能，但很适合【存储】和【在应用程序间交换】数据
* 创建Object的两种方式：
	* new 操作符
	* 对象字面量
		* 左大括号（`{`）出现在[[表达式上下文]]中时代表是一个表达式的开始，出现在【语句上下文】中则表示一个语句块的开始
		* 对象字面量中的尾逗号在古老的浏览器中会报错，但所有现代浏览器都支持这种写法
		* 对象字面量中的【数值属性】会自动转换为字符串
		* 在使用对象字面量方法定义对象时，并不会实际调用Object构造函数
* 多参数函数传参最好的方式是对必选参数使用命名参数，再通过一个对象字面量来封装多个可选参数
* 对象属性的存取有两种语法：
	* 点语法
	* 括号语法（可使用变量访问属性）

### Array
* JS中数组的两个特点：
	* 同一个数组中可存不同类型的数据
	* 数组长度是动态增长的
* 使用数组字面量创建数组时不会调用Array构造函数
* ES6新增的Array构造函数的静态方法：
	* Array.from: 将类数组结构（任何可迭代结构）转换为数组实例
		* 第二个可选参数是一个映射函数，可实现类似于Array.from().map()的效果
		* 第三个可选参数可为映射函数（非箭头函数）中的this添加属性
	* Array.of()，将一组参数转换为数组实例
		* 用于替代 `Array.prototype.slice.call(arguments)`
*	直接使用字面量创建稀疏数组时，空位会被当做`empty` 处理，数组的`map()` 方法会跳过空位，但是使用ES6之后的Array.from() 方法或Array.of()方法创建稀疏数组，空位会被当做`undefined` 处理，`map()` 不会跳过空位
*	数组 length 属性的独特之处在于，它不是只读的。通过修改 length 属性，可以从数组末尾删除或添加元素
*	数组最多可以包含 4 294 967 295 个元素
*	`Array.isArray()`方法相比`instanceof`判断是否数组，可以忽略一个页面内有多个框架时的情况。
*	三个迭代器方法:
	*	`kays()`——返回数组索引迭代器
	*	`values()`——返回数组元素迭代器
	*	`entries()`——返回数组索引/值对迭代器
*	填充方法：`fill(val, start,end)`——向一个已有的数组中插入全部或部分相同的值
*	复制方法： `copyWithin(insertIndex, copyStartIndex, copyEndIndex)`——按照指定范围浅复制数组中的部分内容，然后将它们插入到指 定索引开始的位置。
*	`toLocaleString()`方法也可能返回跟 `toString()`和 `valueOf()`相同的结果，但也不一定。在 调用数组的` toLocaleString()`方法时，会得到一个逗号分隔的数组值的字符串。它与另外两个方法 唯一的区别是，为了得到最终的字符串，会调用数组每个值的` toLocaleString()`方法，而不是` toString()`方法
*	两个排序方法
	*	`sort()`
		*	默认会在每一项上调用 `String()`转型函数，然后比较字符串来决定顺序
		*	使数组的元素都是数值， 也会先把数组转换为字符串再比较、排序
		*	所以它允许传入一个比较函数，有用户指定比较逻辑
	*	`reverse()`——反转顺序
	*	`reverse()`和` sort()`都返回调用它们的数组的引用
*	`concat()`方法可以在现有数组全部元素基础上 创建一个新数组，可以利用它打平数组（只能打平一层）。可以利用参数的`[Symbol.isConcatSpreadable]`属性强制打平或不打平。
*	在所有需要传入位置索引的数组方法中，如果索引为负值，就会以数值长度加上这个负值的结果确定位置。
*	三个严格相等搜索方法：
	*	`indexOf()`——从开头开始搜索，返回匹配到的元素下标，无匹配返回-1
	*	`lastIndexOf()`——从最后开始搜索，返回匹配到的元素下标，无匹配返回-1
	*	`includes()`——从头开始搜索，返回是否匹配到的布尔值
*	两个断言函数搜索方法（在断言函数中定义匹配条件）
	*	`find()`——从最小索引开始，返回第一个匹配的元素
	*	`findIndex()`——从最小索引开始，返回第一个匹配元素的下标
*	五个迭代方法——都不改变原数组。
	*	`every()`——对数组每一项都运行传入的函数，如果对每一项函数都返回 true，则这个方法返回 true
	*	`filter()`——对数组每一项都运行传入的函数，函数返回 true 的项会组成数组之后返回
	*	`forEach()`——对数组每一项都运行传入的函数，没有返回值。
	*	`map()`——对数组每一项都运行传入的函数，返回由每次函数调用的结果构成的数组
	*	`some()`——对数组每一项都运行传入的函数，如果有一项函数返回 true，则这个方法返回 true

* 两个归并方法
	* `reduce(fn, initVal)`——从第一项遍历到最后一项
	* `reduceRight(fn, initVal)`——从最后一项遍历到第一项
	* `fn`接收四个参数
		* 归并函数在上一项上执行后返回的值
		* 当前项
		* 当前项索引
		* 数组本身

### 定型数组
* 在 `WebGL` 的早期版本中，因为 `JavaScript` 数组与原生数组之间不匹配，所以出现了性能问题。图形 驱动程序 `API `通常不需要以` JavaScript `默认双精度浮点格式传递给它们的数值，而这恰恰是 `JavaScript `数组在内存中的格式。
* `Float32Array `实际上是一种“视图”，可以允许 `JavaScript` 运行时访问一块名为 `ArrayBuffer `的 预分配内存。
* `ArrayBuffer`
	* `ArrayBuffer` 是所有定型数组及视图引用的基本单位。
	* `ArrayBuffer` 分配的内存不能超过 Number.MAX_SAFE_INTEGER（2的53次方 -1）字	节。
	* 声明 `ArrayBuffer` 分配的堆内存可以被当成垃圾回收，	不用手动释放
	* 要读取或写入 `ArrayBuffer`，就必须 通过视图。
* `DataView`
	* 是一种视图，专为文件 I/O 和网络 I/O 设计
	* 其` API` 支持对缓冲数据的高度控制，但相比于其他类型的视图性能也差一些
	* `DataView `对缓冲内容没有 任何预设，也不能迭代。
	* 必须在对【已有的】` ArrayBuffer `读取或写入时才能创建 `DataView `实例。
	* 要通过 DataView 读取缓冲，还需要几个组件。
		*    首先是要读或写的字节偏移量。可以看成 DataView 中的某种“地址”。
		*    DataView 应该使用 ElementType 来实现 JavaScript 的 Number 类型到缓冲内二进制格式的转 换。 
		*    最后是内存中值的字节序。默认为大端字节序。
	* ![[Pasted image 20210716162239.png]]
	* “字节序”指的是计算系统维护的一种字节顺序的约 定。DataView 只支持两种约定：大端字节序和小端字节序。大端字节序也称为“网络字节序”，意思 是最高有效位保存在第一个字节，而最低有效位保存在最后一个字节。小端字节序正好相反，即最低有 效位保存在第一个字节，最高有效位保存在最后一个字节
	* JavaScript 运行时所在系统的原生字节序决定了如何读取或写入字节，但 DataView 并不遵守这 个约定。对一段内存而言，DataView 是一个中立接口，它会遵循你指定的字节序。DataView 的所 有 API 方法都以大端字节序作为默认值，但接收一个可选的布尔值参数，设置为 true 即可启用小端 字节序
	* 以第一个字节存0x80, 第二个字节存0x01为例（1个字节8bit）
	
	16进制0x80 --->  二进制 10000000
	16进制0x01 --->  二进制 00000001
	
	大端字节序：
	
 | 地址 | 0x0000 | 0x0001 | 0x0002 | 0x0003 |
 | ---- | ------ | ------ | ------ | ------ |
 | 数据 | 1000   | 0000   | 0000   | 0001  |
 

	读取和计算： 2的0次方 + 2的15次方 = 1 + 32768 = 32769
	
小端字节序：

| 地址 | 0x0000 | 0x0001 | 0x0002 | 0x0003 |
| ---- | ------ | ------ | ------ | ------ |
| 数据 | 0000   | 0001   | 1000   | 0000   |


	读取和计算： 2的7次方 + 2的8次方 = 128 + 256 = 384
	

* DataView 完成读、写操作的前提是必须有充足的缓冲区，否则就会抛出 RangeError：
* 定型数组
	* 定型数组是另一种形式的 ArrayBuffer 视图。虽然概念上与 DataView 接近，但定型数组的区别 在于，它特定于一种 ElementType 且遵循系统原生的字节序
	* 创建定型数组的方式
		* 读取已有的缓冲
		* 使用自有缓冲
		* 填充可迭代结构
		* 填充基于任意类 型的定型数组
		* `<ElementType>.from()`
		* `<ElementType>.of()`
	* 定型数组的构造函数和实例都有一个 BYTES_PER_ELEMENT 属性，返回该类型数组中每个元素的大小
	* 定型数组支持普通数组的大多数方法（concat/pop/push/shift/splice/unshift不支持）
	* 定型数组有一个 Symbol.iterator 符号属性，因此可以通过 for..of 循环和扩展操作符来操作
	* 定型数组也提供了两个新方法，可以快速向外或向内复制数据：
		* `set()`——从提供的数组或定型数组中把值复制到当前定型数组中指定的索引位置。
		* `subarray()`——基于从原始定型数组中复制的值返回一个新定型数组
	* 定型数组中值的下溢和上溢不会影响到其他索引，但仍然需要考虑数组的元素应该是什么类型。定 型数组对于可以存储的每个索引只接受一个相关位，而不考虑它们对实际数值的影响

### Map（映射）

* 基本操作
	* `new Map(可迭代对象)` 新建（初始化）映射
	* `set()` 添加键值对，返回映射实例，故而可以连续调用。
	* `get()` 查询
	* `has()` 检查存在性
	* `.size` 获取键值对数量
	* `delete()` 删除
	* `clear()` 全部删除
	* `forEach()`  迭代键值对
	* `keys()` 迭代键
	* `values()` 迭代值
* Map 可以用任何JS数据类型作为键
* 与Object不同，Map会维护键值对插入顺序，因此可以根据插入顺序执行迭代操作。
* Map实例的`Symbol.iterator`属性引用了它的`entries()`方法，所以可以直接对映射实例使用扩展操作（`...`），把映射转换为数组。
* Map与Object的选择
	* 内存占用：给定固定大小内存，Map大约可以比Object多存储50%的键值对
	* 插入性能：插入Map稍微快一点，如果涉及大量插入操作，那么Map性能更佳
	* 查找速度： 如果涉及大量查找操作，Object会更好一些
	* 删除性能：如果涉及大量删除操作，Map更快。


### WeakMap(弱映射)

* `weak` 描述的是JS垃圾回收程序对待弱映射中键的方式
* 弱映射中的键只能是Object 或者 继承自 Object 的类型。
* 其`API` 是 Map 的子集。它没有`clear()` 操作，没有迭代操作（因为随时可能被销毁）。
* 弱映射中键对外部对象的引用不会阻止外部对象的垃圾回收。（除非有其它地方引用这个键）
* 用途：
	* 实现真正的私有变量【需要使用闭包包装类】
	* DOM节点元数据。因为弱映射实例不会妨碍垃圾回收，所以非常适合保存关联元数据。

### Set

* 基本操作
	* `new Set(可迭代对象)`  新建（初始化）
	* `add()` 增加值，返回集合实例，可连续操作
	* `has()` 检查存在性
	* `delete()` 删除，返回一个布尔值，标识集合中是否存在要删除的值
	* `clear()` 删除全部
	* `.size`取得元素数量
	* `values()` 迭代值
	* `keys()` 上述`values()`的别名
	* `entries()` 返回一个迭代器，可以按照插入顺序产生包含两个元素的数组，这两个元 素是集合中每个值的重复出现
	* `forEach()` 迭代键值对，键和值其实都是值
* Set 可以包含任何JS数据类型作为值
* Set的`Symbol.iterator`属性引用了它自身的`values()` 方法取得迭代器
* 可直接对集合实例使用扩展操作（`...`）,把集合转换为数组

### WeakSet

* `weakSet` 中的`weak` 描述的是JS垃圾回收程序对待弱集合中值的方式
* 弱集合中的值只能是 Object 或者继承自 Object 的类型，尝试使用非对象设置值会抛出 TypeError
* 操作是 Set 操作的子集，没有`clear()`操作和迭代方法
* 弱集合中值对外部对象的引用不会阻止外部对象的垃圾回收。（除非有其它地方引用这个值）
* 目前知道的用途是给DOM节点打标签

