# CSS表格布局原理

## 1. 表格式化（表编排）

### 1.1 表元素与内部表元素
* 表元素：`table`
* 内部表元素：生成矩形框，这些框有内容、内边距和边框，但是**没有外边距**；——因此不能通过指定外边距来定义单元格之间的间隔

### 1.2 表编排的6个规则

* 每个行框包含一行表格单元，所有行按其在文档中的书写顺序依次地填充表（表头与脚注例外）。
* 一个行组包含多少个行框，该行组框就包含多少个表格单元 
* 列框包含一列或多列表格单元，他们按照在文档中的出现顺序放置。
* 列组中包含多少个列框，该列组框中就包含多少个表格单元。
* 单元格的跨多行和跨多列由文档语言定义而非CSS定义。
	* 每个跨行或跨列的单元格是一个矩形框，它的高度和宽度分别为一个或多个单元格的高度或宽度；
	* 这个矩形框的顶行在作为该单元格父元素的行中。
	* 该单元格必须尽可能向行框的起点方向靠，但不能覆盖其它单元格框

*  单元格不能超出表或行组的最后一个行框。

另外3个注意点：
* 表格单元是矩形，但不必都是相同大小
* 给定列中所有的表格单元宽度相等
* 一个表格行中给定所有表格单元高度相等


## 2. 表显示值(display属性值)

* `table`：它指定一个元素定义了一个块级表(`<table>`)
* `inline-table`：定义了一个行内级表，即一个生成行内框的矩形块。
* `table-row`：指定一个元素时一个单元格的行(`<tr>`)
* `table-row-group`：指定一个元素时一个或多个行的组（`<tbody>`）
* `table-header-group`：指定一个表标题组（`<thead>`）
* `table-footer-group`：指定一个脚注行组(`<tfoot>`)
* `table-column`：描述了一个单元格的列，有这个值的元素并不显示，只作为结构表示(`<col>`)
* `table-colnmn-group`：声明一个元素时一个或多个列的组，也不显示，只用来表示结构（`<colgroup>`）
* `table-cell`：指定一个元素表示表中的单个单元格。（`<th>,<td>`）
* `table-caption`：定义一个表的总标题。（`<caption>`）

### 以行为主

* 必须显示地声明行，而列是从单元格行的布局推导出来的。

### 列

* 虽然单元格在文档源中是行元素的后代，但它们可能同时属于两个上下文（行和列）
* CSS中的列和列组只接受4种样式
	* `border`：
		* 只有当`border-collapse` 属性设置为`collapse`时才能为列和列组设置边框
		* 列和列组边框会参与设置各单元格边界边框样式的合并算法
	* `background`：只有当单元格及其行有透明背景时，列或列组的背景才可见
	* `width`：定义了列或列组的最小宽度，列或列祖中单元格的内容可能要求列更宽
	* `visibility`：
		* 如果列或列组`visibility`属性的值为`collapse`， 则该列或列组中所有的单元格都不显示。
		* 从合并列跨到其他列的单元格会被剪裁。
		* 表的总宽度会减去已合并列的宽度。
		* 其他值会被忽略


## 匿名表对象

当CSS作者没有书写必要元素时（例如`缺少<tr>`），CSS会在缺失元素的位置将遗漏的组件作为匿名对象进行插入。

### 对象插入规则

*  如果一个`table-cell`元素的父元素不是`table-row`元素， 则会在该元素与其父元素插入一个匿名的`table-row`对象。
*  如果一个`table-row`元素的父元素不是`table、inline-table`或`table-row-group`，则会在该元素及其父元素之间插入一个匿名`table`元素。
*  如果一个`table-column`元素发父元素不是`table、inline-table或table-column-group` 元素，则在该元素及其父元素之间插入一个匿名的`table`元素。
*  如果一个`table-row-group、table-header-group、table-footer-group、table-column-group`或`table-caption`元素的父元素不是`table`元素，则会在该元素及其父元素之间插入一个匿名的`table`元素
*  如果一个`table` 或`inline-table`元素的子元素不是`table-row-group、table-header-group、table-footer-group、table-row`或`table-caption`元素，则在该`table`元素与其子元素之间插入一个匿名`table-row`对象。
*  如果一个`table-row-group、table-header-group`或`table-footer-group` 元素的子元素不是`table-row`元素，则在该元素及其子元素之间插入一个匿名`table-row`对象。
*  如果一个`table-row`元素的子元素不是`table-cell`元素，则在该元素和其子元素之间插入一个匿名`table-cell`对象。

## 表层

* 表从下向上一层一层绘制，绘制顺序从下向上为： 表->列组->列->行组->行->单元格
* 由于列样式在行样式的下面，所以行背景会覆盖列背景
* 默认地，所有表元素的背景都是透明的。

## 表标题

*  表标题（`<caption>`）的位置与在HTML结构中的位置无关，它总是处于表格最上面或最下面。
*  `caption-side`属性用来规定表标题处于表上方还是下方
*  表标题会继承表的可继承样式（比如文字颜色）

## 表单元格边框

### 两种边框模型

* 分割边框模型（`separate`）
* 合并边框模型(`collapse`)
* 可以设置`border-collapse`属性来选择要使用的边框模型

### 分割单元格边框

*  每个单元格都与其他单元格分开一定距离
*  单元格的边框彼此不会合并
*  通过`border-spacing`属性可以设置边框间的间隔距离（应用于`table`或`inline-tabel`元素上）
*  在此模型中，不能为行、行组、列和列组设置边框
*  如果单元格无内容，则它的表现则由`empty-cells`属性来控制：
	*  设置为`show`，会画出单元格的边框与背景
	*  设置为`hide`，不会画出单元格任何部分，类似于`visibility:hidden`的效果

### 合并单元格边框

* 与分割单元格边框的区别
	* 表元素不能有任何内边距，但可以有外边距
	* 边框可以应用到单元格、行、行组、列和列组
	* 单元格边框之间绝对不会有任何间隔。边框合并时【最有意思的】边框会胜出
	* 一旦合并，单元格之间的边框会在单元格间的假想表格线上居中。

* 合并边框布局
	* 单元格之间的边框，一半边框放在单元格之间表格线的一边，另一半放在另一边。如果边框宽度是个奇数，则用户代理可能会调整或偏移边框。
	* 外部框可能会超出表的宽度
* 边框胜出规则：
	* 如果某个合并边框的`border-style`为`hidden`，它会优于所有其他合并边框，这个位置上的所有边框都隐藏。
	* 如果某个合并边框的`border-style`为`none`，它的优先级最低。
	* 如果至少有一个合并边框的`border-style`值不是`none`，而且所有合并边框的`border-style`值都不是`hidden`，则较宽的边框胜出。
	* 在上面一种情况的基础上，如果合并边框的宽度都相同，则按照`border-style`的值的以下顺序确定优先级：`double > solid > dashed > dotted > ridge > outset > groove > inset`
	* 如果合并边框的样式和宽度都一样，但是颜色不同，则按下面顺序使用元素的颜色确定优先级：`cell > row > row group > column > colnmn group > table`, 这里可以发现，正是表的层渲染顺序的逆序，即后渲染的会覆盖先渲染的。
	* 如果合并边框的样式、宽度且来自于同类型的元素，而颜色不同，则颜色取左边和上边单元格的边框颜色。（如果是从右向左的书写模式，则取右边和上边单元格的边框颜色）

## 表大小

### 两种表格布局

* 固定宽度布局
* 自动宽度布局

通过`table-layout`来确定使用哪种宽度计算方法··

* `fixed` ： 固定宽度布局
* `auto`： 自动宽度布局

固定宽度布局比自动宽度布局的计算更快



### 固定布局

* 固定布局的计算不依赖于表单元格的内容，而是由个元素的`width`值决定

* 固定布局的计算步骤：

  1. `width`值不是`auto`的所有列元素会根据`width`值设置该列的宽度
  2. 如果一个列的宽度为`auto`，则根据该单元格的宽度设置此列的宽度，如果这个单元格跨多列，则宽度在这些列上平均分配
  3. 在以上两步后，如果列的宽度仍为`auto`， 会自动确定其大小，是其宽度尽可能相等。

  此时，表的宽度设置为表的`width`或各列宽度之和（二者中的较大者），如果表宽度大于其列宽总和，将二者之差除以列数，再把得到的这个宽度增加到每列上。（每列并不会完全等宽）

### 自动布局


* 自动布局之所以慢，是因为它要进行多轮计算，这是由于自动布局时基于内容长度来计算的，而在查看完所有内容之前，浏览器是无法确定表的布局的
* 自动布局的第一轮计算步骤：
	1. 计算每个单元格的最小和最大单元格宽度
	 a. 对于最小宽度
		  * 如果单元格`width`值大于最小可能宽度，则为`width`值
		  * 如果`width`值为`auto`，则为最小内容宽度
	  b. 对于最大宽度，计算出完全显示内容的所需宽度（不包括换行）就是最大宽度
  2. 计算每一列的最小和最大列宽
	  1. 列的最小宽度由所有单元格中最小单元格宽度的最大值确定，如果为该列指定的`width`值大于列中所有最小单元格宽度，最小列宽则设置为这个`width`值
	  2. 计算最大宽度，取该列中所有单元格的最大单元格宽度的最大值。如果已经为列指定了一个`width`值，而且大于该列中的所有最大单元格宽度，最大列宽则设置为该`width`值。
  3. 如果一个单元格跨多列，最小列宽之和必须等于这个跨列单元格的最小单元格宽度。类似地，最大列宽之和必须等于跨列单元格的最大宽度。如果列宽之和与单元格宽度有差距，浏览器会把这个差距在所跨列上平均分配。
* 第二轮计算步骤
	1. 如果表的计算宽度值不是`auto`，将这个计算表宽度值与所有列宽再加上所有边框和单元格间隔之和相比较。二者中较大的一个就是表的最终宽度。如果表的计算宽度值大于列宽、边框和单元格间隔之和，所有列的宽度都会增加一个相等的量，使得刚好将表完全填充。
	2. 如果表的计算宽度值为`auto`，通过将列宽、边框和单元格间隔相加来确定表的最终宽度。

## 高度


* 如果表的高度是`auto`，其高度则是表中所有行的行高再加上所有边框和单元格间隔的总和
* 表的高度计算在CSS2.1中没有做出详细和确定的规范标准，大多数时候由浏览器决定，所以要尽量避免为表格设置高度

## 对齐
* 水平对齐：`text-align`：此时单元格会处理为一个块级框
* 垂直对齐： `vertical-align`：
	* `top`：单元格内容的顶端与其行顶端对齐；对于跨行单元格，与其所跨第一行的顶端对齐。
	* `bottom`: 单元格内容的底端与其行底端对齐，对于跨行单元格，与其所跨最后一行的底端对齐。
	* `middle`：单元格内容的中间与其行中间对齐，对于跨行单元格，与其缩跨行的中间对齐
	* `baseline`：单元格的基线与其行的基线对齐，对于跨行单元格，与其所跨第一行的基线对齐。【行的基线由该行所有单元格中最低初始单元格基线（也就是第一行文本的基线）定义】
* 浏览器会通过自动增加单元格本身的【内边距】来完成对齐
* 单元格内容对齐步骤
	1. 如果某些单元格式基线对齐，则确定该行基线，并放置这些基线对齐单元格的内容
	2. 放置所有顶端对齐单元格的内容。此时，由已经放置了内容的单元格的最低单元格底端决定行的临时高度
	3. 如果剩下的单元格是居中对齐或底端对齐，而且内容高度大于临时行高，则行高增加到可以包含其中最高的单元格
	4. 放置所有余下单元格的内容，如果单元格内容高度比行高小，则增加单元格内边距，使之适应行高。

