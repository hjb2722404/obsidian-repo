简悦 | 图形学 光栅化详解（Rasterization） - 简书

计算机的屏幕是二维的平面坐标，以左上角为原点，x 轴向右增加，y 轴向下增加。

![7943693-18e72ea8cba32a53.jpg](https://gitee.com/hjb2722404/tuchuang/raw/master/img/20201231115416.jpg)

1920×1080 屏幕
在 3D 图形学中，物体是 3 维的，拥有 X, Y, Z 三个坐标，并且拥有 R, G, B 三种颜色，alpha 透明度，U, V 贴图坐标，N 法线。
三维物体在二维屏幕上的显示，大致分为以下几步：
1. 坐标变换（transform）
将场景中的三维坐标转换为二维坐标，这个请参考我的文章[坐标系空间变换](https://www.jianshu.com/p/09095090c07f)。
2. 颜色计算（shade）
计算每个顶点的颜色，通过 UV 贴图的颜色，结合光照，透明度等，计算出模型每个顶点的具体颜色（R, G, B）。这个在后面也会讲，本期不做介绍。
3. 光栅化（rasterization）

假定屏幕分辨率为 1920×1080，在二维屏幕渲染（光栅化）时，内存中 frame buffer 只保存着 1920×1080 个屏幕点的颜色，然后一个一个的画到屏幕上。（它的实现方式是以一个 1920×1080 长的一维数组储存每个顶点的 RGB 颜色，然后遍历数组画出来）

什么 X, Y, Z，什么 alpha 之类的 frame buffer 都没有的，在 frame buffer 里只有 3 个值：R, G, B。
X, Y, Z, alpha 等等属性要在另外的地方存储。
**光栅化，就是计算出 1920×1080 这么长的 RGB 数组中，每一个 RGB 的值。**
在第二步中，我们计算出了 3D 模型每个顶点的颜色，这个是基于 3 维坐标的，顶点的三维坐标可以是**小数**。

但在屏幕渲染时，屏幕是只有 X,Y 二维的，并且其像素点坐标都是**整数**。1920×1080 的屏幕只有 1920×1080=2073600 个像素点。所以光栅化的连点描边是一个近似过程。

![7943693-1d2adb1060b6d402.jpg](https://gitee.com/hjb2722404/tuchuang/raw/master/img/20201231115421.jpg)

PR 线段的屏幕近似

PS:

目前主流的面片分割是三角形分割，所以大家在 3DS MAX 或者 MAYA 里看 3D 模型的网格，基本都是三角形网格，但也有以四边形为最小分割的算法，这里不涉及，我们认为 3D 模型的面片单元都是三角形。

那么一个三角形的颜色怎么规定呢？
（1）三个顶点颜色取平均值
（2）取某一个顶点的颜色
（3）三个顶点颜色的渐变
这三种方法都可以，根据实际情况自行斟酌。
**光栅化主要有以下几步：**
1. 读取模型的顶点，3 个 3 个的读，因为要画三角形。
2. 将 3 个顶点两两连成线，形成三角形。
3. 计算屏幕像素点在三角形内还是三角形外。在三角形内部的，就上色（颜色是之前算出来的），在三角形外部的，就不上色。

（**注意**：如果一个三角形挡在另一个三角形前面，我们应该只画前面的三角形。所以这里还需要比较一下正准备上色的这个像素点是不是已经上过色了。如果这个像素点已经上过色了，并且它是被 Z=1 的顶点上的色，而我们正准备上色的这个顶点的 Z=2（说明这个顶点被挡在了后面），那么这个顶点就不应该上色，因为它是被挡住的点。）

4. 不断的循环，直到画完 3D 模型的所有三角形，这样一个模型就出来了！
那么，假设我们已经得到了 3 个顶点的坐标，并且已知这个三角形是红色。
v1 (-1.5, 1.5, 1.5)
v2 (1.5, 1.5, 1.5)
v3 (0.2, 0.2, 0.2)
**如何判断屏幕的哪些像素点在该三角形内部？**
主流的算法有两种：
1.LEE（Linear Expression Evaluation）
2.Scan Line
本期只讲 LEE，因为 Scan Line 我没有亲自搞过。
**LEE 大致原理如下：**
1. 首先因为屏幕只有二维，所以判断点和边的位置关系的时候可以先不管 Z，Z 只是用来判断前后遮挡的。
2. 按照顺时针（或者逆时针）的顺序，连接 v1v2, v2v3, v3v1，这样就得到了三条边。
3. 假定边的头是（X+dX, Y+dY），尾是（X, Y）
计算这 3 条边的方程：E(**x,y**) = dY(**x**-X)-dX(**y**-Y)
展开之后是 dY***x** + (-dX)***y** + (dX*Y-dY*X) = 0
即 A**x** + B**y** + C =0
其中 A = dY, B = -dX, C = dX*Y-dY*X
我们把 v1v2, v2v3, v3v1 三条边的 A, B, C 都求出来，就得到了 3 条边的方程 E1, E2, E3。
4. 将屏幕像素点的 x,y 带入方程，A1**x** + B1**y** + C1 = E1，如果点在边上，则 E1=0，如果点不在边上，则 E1！=0。
5. **最神奇的地方来了。**

如果点（x,y）带入 3 个方程的结果 E1, E2, E3 同时大于 0 或者同时小于 0，即**同号**，则该点在三角形内，如果**异号**，则在三角形外。

6. 每次获得 3 个点之后，取出其中的 min_x, max_x, min_y, max_y 构成的四边形，将屏幕像素点（x,y）中，在该范围内的点取出，带入 LEE 公式比较结果。

如果该点在三角形内，并且没有被遮挡（需要对 Z 进行判断），则上色，否则不上色。不断迭代，直到所有的三角形都被处理完成，3D 模型也画到了屏幕上。
**需要注意的地方：**
1. 如何判断遮挡，即得到三角形内的点的 Z 值？
答：我们知道了 v1, v2, v3 三个点，可以求三角形平面方程，求出之后，只需要将某个点的（x,y）代入，即可求出 z。
平面方程一般式为：Ax + By + Cz + D = 0
取 E1, E2 两个边向量，进行叉乘，得到**法向量 N(A,B,C)**。
没错，你没看错，N 的 X, Y, Z 即是 A, B, C。（数学真神奇）
然后取 v1(x, y, z) 带入方程，求出 D，平面解析式就得到了。
然后将想求 z 的点的 x,y 带入，就可以求出 z 了。
2. 屏幕的 Z 轴是朝里的，所以 z 越大说明离我们越远，z 越小就里我们越近，近处的会遮挡远处的。
3. LEE 的特殊情况
由于多个三角形的边和边是互相挨着的，所以如果直接按上面的方法画，会有很多边重复画了 2 遍，为了提高渲染效率，我们需要**保证每条边只画一遍**。
怎么保证呢？
**答：只画三角形的左边和上边**
**如何定义左边和上边?**
由于重画这个问题只出现在边上，对于三角形内部的像素点，都是只画一次的，所以不用考虑内部点，只考虑三条边上的点。
![7943693-34644f81d884e304.jpg](https://gitee.com/hjb2722404/tuchuang/raw/master/img/20201231115426.jpg)

如图所示：

1）假定三角形 v1v2v3 是这样的，我们当前要上色的像素点为 P1（红色），落到了 v1v3 这条边上，那么就取不在这条边上的顶点 v2，计算过 v2 的水平线与 v1v3 的交点 R1，如果 R1 在 v2 的右侧，即 R1.x > v2.x，那么说明 P1 是落在了**右侧**的边，所以**不画**

2）假定我们当前要上色的像素点为 P2（绿色），落到了 v2v3 这条边上，那么就取不在这条边上的顶点 v1，计算过 v1 的水平线与 v2v3 的交点 R2，如果 R2 在 v1 的右侧，即 R2.x > v1.x，那么说明 P2 是落在了**右侧**的边，所以**不画**

3）假定我们当前要上色的像素点为 P3（蓝色），落到了 v1v2 这条边上，那么就取不在这条边上的顶点 v3，计算过 v3 的水平线与 v1v2 的交点 R3，如果 R3 在 v3 的右侧，即 R3.x > v3.x，那么说明 P3 是落在了右侧的边，但图中是 R3.x < v3.x，所以 P3 落在了**左侧**边，**要画**

4）**如果存在垂直边或者水平边，怎么判断左右？**
垂直边和上面是一种情况，不用单独拿出来考虑。
水平边的画，只画上方，即只画**左边和上边**

还是看上图，假定边 v2v3 是水平的，那么我们取 v1，发现 v1 的 y 比较小，即 v1 在 v2v3 上方，那么边 v2v3 就是**下边**，所以**不画**，反之则画。

*可以参考的论文*

1. Siggraph 1985 - "Fast Spheres, Shadows, Textures, Transparencies, and Image Enhancements in Pixel-Planes," Henry Fuchs,et. al.

2. 2000 Sig/Euro Workshop on Graphics Hardware - "Tiled Polygon Traversal Using Half-Plane Edge Functions," Joel McCormack, Robert McNamara

3. Siggraph 1988 - "A Parallel Algorithm for Polygon Rasterization," Juan Pineda

4. Siggraph 2005 - “Resolution-Independent Curve Rendering Using Programmable Graphics Hardware,” Charles Loop, Jim Blinn