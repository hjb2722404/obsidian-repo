前端面试经验（三）

|     |
| --- |
| **前端面试经验（三）** |
| 非技术问题 |
|     |
| 问题  | 答案  |
| 请把两个数组 ['A1', 'A2', 'B1', 'B2', 'C1', 'C2', 'D1', 'D2'] 和 ['A', 'B', 'C', 'D']，合并为 ['A1', 'A2', 'A', 'B1', 'B2', 'B', 'C1', 'C2', 'C', 'D1', 'D2', 'D']。 | var arr1 = ['A1', 'A2', 'B1', 'B2', 'C1', 'C2', 'D1', 'D2'];<br>var arr2 = ['A', 'B', 'C', 'D'];<br>var arr = arr1.concat(arr2);<br>arr = arr.sort(function(a,b){ return a.codePointAt(0) - b.codePointAt(0) \|\| b.length-a.length \|\| a.codePointAt(1) - b.codePointAt(1) });<br>考点：concat和sort |
| 改造以下代码，使之输出0-9<br>for (var i = 0; i< 10; i++){    setTimeout(() => {        console.log(i);    }, 1000)} | for (var i = 0; i < 10; i++) {<br>  (function(i){<br>    setTimeout(() => {<br>      console.log(i);<br>    }, 1000);<br>  })(i);<br>}<br>或者<br>for (let i = 0; i < 10; i++) {<br>    setTimeout(() => {<br>      console.log(i);<br>    }, 1000);<br>}<br>考点：使用闭包或块级作用域解决for循环内人setTimeout引用值问题 |
| ### **Virtual DOM 真的比操作原生 DOM 快吗？谈谈你的想法** | 1.JS引擎与UI引擎占用同一个线程，是互斥关系，其中一个运行时另一个会挂起；<br>2.DOM API操作的消耗远高于JS；导致DOM操作进行时，JS操作长时间挂起【DOM API是浏览器文档对象提供给JS引擎的一组API接口，当JS调用DOM API时，相当于调用外部函数，将会用很多时间去进行保存上下文和恢复上下文等操作】<br>3.从时间复杂度看，<br>  原生DOM更新一次innerHTML,它的开销是 渲染HTML内容 O(template size) +重新建立所有DOM元素 O(DOM size)<br>  Virtual DOM的更新开销是：  render Virtual DOM + diff O(template size) + 必要的 DOM 更新 O(DOM change)<br>尽管 render Virtual DOM(在JS中进行) + diff（也在JS中进行） 操作比渲染HTML要慢，但是后面DOM更新时，原生的开销与页面大小密切相关，而Virtual DOM则只和发生变动的DOM数量相关，基于第2点，这里，如果DOM变动较少时，则Virtual DOM会快很多，但如果DOM变动量接近DOM总量时，则由于前半部分开销的优势，原生会更快。<br>4.从操作次数看<br>第3点其实只针对只更新一次的情况，但实际情况是，我们的页面可能会在一段时间内做多次更新DOM的操作，而Virtual DOM只会在第一次创建时才进行 render Virtual DOM操作，后面就只有diff了，所以对DOM的操作次数比较多的情况下，Virtual DOM会更快 |
| var b = 10;(function b(){    b = 20;    console.log(b); })();<br>运行结果？ | [Function:b]  或者  'function b(){b=20;console.log(b);}'<br>1.function b..外层的括号为分组操作符，而分组操作符内部只可能是表达式，所以内部function b(){}是一个命名函数表达式<br>2. 命名函数表达式的名字只在新定义的函数作用域内有效，即b标识符在b函数内有效<br>3.函数表达式的名字不可更改，所以在名为b的函数表达式中企图修改b的值为20，在非严格模式下直接静默失败了<br>4.此时console b的值，由于b标识符在b函数内有效，又由于b=20企图修改b失败，所以此时在命名函数作用域内的b仍旧指向这个函数表达式。<br>5.所以最后输出结果为 [Function:b] （node环境）等价于 'function b(){b=20;console.log(b);}'（浏览器环境） |
| var b = 10;(function b(){    b = 20;    console.log(b); })();<br>改造以上代码，使之分别打印10和20 | 打印20：<br>var b=10; (function b(b){ b=20; console.log(b);})() 【考察函数表达式传参】<br>var b=10; (function b(){var b=20; console.log(b);})() 【考察局部作用域】<br>打印10：<br>var b=10; (function b(){ b=20; console.log(this.b);})()<br>【考察this指向，这里指向window全局对象<br>因为是函数表达式，即使在分组表达式中，也还是在全局环境中，执行时也在全局环境】 |
| ### **浏览器缓存读取规则**<br>可以分成 Service Worker、Memory Cache、Disk Cache 和 Push Cache，那请求的时候 from memory cache 和 from disk cache 的依据是什么，哪些数据什么时候存放在 Memory Cache 和 Disk Cache中？ | 缓存位置：<br>- service worker<br>    - 浏览器独立线程，因涉及请求拦截必须使用HTTPS<br>    - 可自由定制缓存哪些文件、如何匹配缓存、如何读取缓存，且缓存可持续<br>    - 工作原理：注册--监听--请求拦截判断是否有缓存<br>- memory cache<br>    - 存储在内存中，缓存脚本与图片<br>    - 读取高效，持续时间短，容量小<br>    - 随页面关闭而被释放<br>    - 可利用 preloader 相关指令预下载资源<br>- disk cache<br>    - 存储在硬盘中，缓存样式文件<br>    - 读取较慢，但容量大，持续时间长<br>- push cache<br>    - HTTP/2的内容，只有上述三种缓存都未命中，才会生效<br>    - 只在会话中存在，会话结束后被释放<br>    - 缓存只能被使用一次<br>缓存策略：<br>- 强缓存：expires和cache-control，由于前者存在时间准确性问题，一般使用后者<br>- 协商缓存：last-modified/if-modified-since 或者 Etag/if-none-match，Etag比前者精确度更高，但性能略差，服务器校验优先使用Etag<br>- 强缓存先于协商缓存进行，协商缓存失效，返回200，重新返回资源与缓存标识，协商缓存生效则返回304，继续使用缓存<br>用户行为<br>- 地址栏输入地址：查找disk cache中是否有匹配，没有匹配则发起网络请求<br>- 普通刷新页面（F5）：优先使用memory cache，其次才是disk cache<br>- 强制刷新（Ctrl+F5）: 不使用缓存 |
| ### **使用迭代的方式实现 flatten 函数** | function flatten(arr){<br>  var newArray = [];<br>  for(var i=0;i<arr.length;i++){<br>    if(arr[i] instanceof Array){<br>      newArray = newArray.concat(flatten(arr[i]));<br>    }else{<br>      newArray.push(arr[i]);<br>    }<br>  }<br>  return newArray;<br>} |
| ### **为什么 Vuex 的 mutation 和 Redux 的 reducer 中不能做异步操作？** | redux:因为更改state的函数必须是纯函数，纯函数既是统一输入就会统一输出，没有任何副作用；如果是异步则会引入额外的副作用，导致更改后的state不可预测；<br>vuex：因为mutation中的异步操作会导致devtool无法追踪回调函数中的状态改变。 |
| var a = ?;if(a == 1 && a == 2 && a == 3){     console.log(1);}<br>a取什么值，最后结果打印出1 | var a ={<br>  value:1,<br>  valueOf:function(){<br>   return a.value++;<br> }<br>} |
| ### **介绍下 BFC 及其应用** | 块级格式化上下文：<br>- 文档页面由盒子（Box）组成；<br>- 【元素类型】与【display】属性决定盒子类型<br>- 不同类型的盒子由不同的格式化上下文（一个决定如何渲染内容的容器）<br>- 有三种盒子类型：块级盒子、行内盒子、run-in盒子<br>- 有四种格式化上下文：<br>    - BFC：块级格式化上下文，  它是一个独立的渲染区域，只有块级盒子参与， 它规定了内部的块级盒子如何布局，并且与这个区域外部毫不相干<br>    - IFC：行内格式化上下文，可以用来做垂直居中和水平居中<br>    - GFC：网格格式化上下文，主要用于网格布局<br>    - FFC：自适应格式化上下文，主要用于弹性布局<br>- 块级盒子参与块级格式化上下文<br>- BFC规则：<br>    - 内部的盒子会在【垂直方向】一个接一个的放置<br>    - 盒子间垂直方向的距离由 margin 属性决定<br>    - 同一个BFC内的两个相邻盒子的 margin会重叠<br>    - 每个盒子左边都与包含块左边接触<br>    - BFC的区域不会与浮动盒子重叠<br>    - BFC容器内的子元素不会与外部元素相互影响<br>    - 【计算BFC的高度时，浮动元素参与计算】<br>- 生成BFC<br>    - 元素：根元素<br>    - 属性：<br>        - float 不为none 【浮动元素】<br>        - position 为 absolute或fiex 【绝对和固定定位元素】<br>        - display 为 inline-block/table-cell/table-caption/flex/inline-flex【table布局、弹性布局，内联块级元素】<br>        - overflow 不为 visible (hidden/scoll/auto)<br>应用：<br>- 清除浮动<br>- 防止margin重叠<br>- 自适应两栏布局 |
| ### **在 Vue 中，子组件为何不可以修改父组件传递的 Prop**<br>如果修改了，Vue 是如何监控到属性的修改并给出警告的。 | 因为vue设计是单向数据流，数据的流动方向只能是自上往下的方向；<br>在vue 底层，做了一个类似全局标记Flag;它的实现原理，还是Object.defineProperty()API;  window.isUpdatingChildComponent = false; 相当于一个Flag;只有当在父组件中修改传递给子组件的Prop值的时候，才会被赋值为True; 在子组件Proxy.vue 中代理父组件传递的Prop值； 使用 this.$forceUpdate(); 强制更新； 这时候，触发代理中的setter；提示不可以在子组件中直接修改父组件传递的Prop值的警告； |
| var a = 10;<br>(function () {<br>console.log(a)<br>a = 5<br>console.log(window.a)<br>var a = 20;<br>console.log(a)})()<br>输出什么？ | undefined  匿名函数中 var a= 20; 中的 var a 部分提升，此时尚未赋值，值为undefined<br>10   经过 a=5赋值后，匿名函数作用域中的 a的值变为5，而全局作用域（window对象）中的a 的值仍为10<br>20   经过 var a =20;   匿名函数中的 a 被赋值为20 |
| ### **实现一个 sleep 函数**<br>比如 sleep(1000) 意味着等待1000毫秒，可从 Promise、Generator、Async/Await 等角度实现 | function sleep(time){<br>  return new Promise(resolve => setTimeout(resolve,time));<br>}<br>async function test(){ console.log('0'); await sleep(1000); console.log('1000')} |
| ### **使用 sort() 对数组 [3, 15, 8, 29, 102, 22] 进行排序，输出结果** | [3,15,8,29,102,22].sort(function(a,b){return a-b}); |
| ### **介绍 HTTPS 握手过程** |     |
| *   |
| * * |
| 他山之石 |
| *摘录相关精彩书评…* |