前端面试经验（一）

|     |
| --- |
| **前端面试记录（一）** |
| 面试问题 |
| 1.期望薪资；2.离职原因；3.个人经历； |
| 笔试题目 | 答案复盘 |
| 1.阐述一下CSS Sprites? | - 又叫“精灵图”，是一种网页图片应用处理方式<br>- 允许将一个页面涉及到的所有零星图片包含到一张大图中<br>- 利用css的background-image/background-repeat/background-position定位出图片位置<br>- 优点是减少图片请求次数、减小图片总体积、解决了图片命名困扰、更换风格方便<br>- 缺点：在自适应页面中易出现背景断裂、开发麻烦，需要精确设计位置、维护麻烦，更换某个小图片要重新把大图做一遍，如果位置改变了还得改CSS |
| 2.CSS选择器都有哪些，哪些属性可以继承 | - 类别选择器、标签选择器、ID选择器、后代选择器、子选择器、伪类选择器、通用选择器、群组选择器、相邻同胞选择器、属性选择器、伪元素选择器、结构性伪类选择器、UI元素状态选择器<br>- 字体系列属性：font/font-family/font-weight/font-size/font-style/font-variant/font-stretch/font-size-adjust/<br>- 文本系列属性：text-indent/text-align/line-height/word-spacing/letter-spacing/text-transform/direction/color<br>- 元素可见性：visibilty;<br>- 表格布局属性：caption-side/border-collapse/border-spacing/empty-cells/table-layout<br>- 列表属性：list-style-type/list-style-image/list-style-position/list-style<br>- 生成内容属性：quotes<br>- 光标属性：cursor<br>- 页面样式属性：page/page-break-inside/windows/orphans<br>- 声音样式属性：speak/speak-punctuation/speak-numeral/speak-header/speech-rate/volume/voice-family/pitch/pitch-range/stress/richness/azimuth/elevation |
| 3.解释下CSS3的flexbox,以及应用场景 | - 是一种当页面需要适应不同的屏幕大小以及设备类型时确保元素拥有恰当的行为的布局方式<br>- 引入弹性盒布局模型的目的是提供一种更加有效的方式来对一个容器中的子元素进行排列、对齐和分配空白空间。<br>- 弹性盒子由弹性容器(Flex container)和弹性子元素(Flex item)组成。弹性容器通过设置 display 属性的值为 flex 或 inline-flex将其定义为弹性容器。弹性容器内包含了一个或多个弹性子元素。 |
| 4.BFC规范的理解 | - 它是指一个独立的块级渲染区域，只有Block-level BOX参与，该区域拥有一套渲染规则来约束块级盒子的布局，且与区域外部无关。<br>- CSS2.1中规定满足下列CSS声明之一的元素便会生成BFC。根元素/float的值不为none/overflow的值不为visible/display的值为inline-block、table-cell、table-caption/position的值为absolute或fixed/<br>- 约束规则如下：<br>- 生成BFC元素的子元素会一个接一个的放置。垂直方向上他们的起点是一个包含块的顶部，两个相邻子元素之间的垂直距离取决于元素的margin特性。在BFC中相邻的块级元素外边距会折叠。<br>- 生成BFC元素的子元素中，每一个子元素做外边距与包含块的左边界相接触，（对于从右到左的格式化，右外边距接触右边界），即使浮动元素也是如此（尽管子元素的内容区域会由于浮动而压缩），除非这个子元素也创建了一个新的BFC（如它自身也是一个浮动元素）。 |
| 5.let与var的区别 | - ES6可以用let定义块级作用域变量，var不能<br>- let存在暂时死区没有变量提升，而var有；<br>- let变量不能重复声明，而var 可以 |
| 6.写一个mul函数，使用方法如下：<br> console.log(mul(2)(3)(4)); // 24<br> console.log(mul(4)(3)(4)); // 48 | - 函数柯里化指的是将能够接收多个参数的函数转化为接收单一参数的函数，并且返回接收余下参数且返回结果的新函数的技术。<br>- 函数柯里化的主要作用和特点就是参数复用、提前返回和延迟执行。<br>- 函数柯里化思想：一个JS预处理的思想，降低通用性，提高适用性。<br>- 实现：<br>- function mul() { var args = [].slice.call(arguments); var fn = function() { var newArgs = args.concat([].slice.call(arguments)); return mul.apply(this, newArgs); } fn.toString = function() { return args.reduce(function(a, b) { return a * b; }) } return fn; } |
| 7.下面的代码将输出什么，为什么？<br> 0.1+0.2；<br> console.log(0.1+0.2 ==  0.3) | 0.30000000000000004/false<br>原因：  IEEE 754 标准的 64 位双精度浮点数的小数部分最多支持53位二进制位，所以两者相加后，因浮点数小数位的限制而截断的二进制数字，再转换为十进制，就成了 0.30000000000000004，所以在进行算术计算时会产生误差 |
| 8.谈一下闭包，并举一个例子； | - 当函数可以记住并访问所在的词法作用域时，就产生了闭包。<br>- function  add()  {  var  x =  1;  return  function()  {  console.log(++x); }; }  var  num = add() |
| 9.谈一下对Vue生命周期的理解 | - 总共分为8个阶段创建前/后，载入前/后，更新前/后，销毁前/后。<br>- 创建前/后： 在beforeCreated阶段，vue实例的**挂载元素**$el和**数据对象**data都为undefined，还未初始化。在created阶段，vue实例的数据对象data有了，$el还没有。<br>- 载入前/后：在beforeMount阶段，vue实例的$el和data都初始化了，但还是**挂载之前**为**虚拟的dom节点**，**data.message**还未替换。在mounted阶段，vue实例挂载完成，**data.message成功渲染**。<br>- 更新前/后：当data变化时，会触发**beforeUpdate和updated**方法。<br>- 销毁前/后：在执行destroy方法后，对data的改变不会再触发周期函数，说明此时vue实例已经解除了事件监听以及和dom的绑定，但是dom结构依然存在 |
| 10.require/exports与import/export区别 | - 规范不同<br>    - require 是 AMD规范引入方式<br>    - import是es6的一个语法标准，如果要兼容浏览器的话必须转化成es5的语法<br>- 调用时间<br>    - require是运行时调用，所以require理论上可以运用在代码的任何地方<br>    - import是编译时调用，所以必须放在文件开头<br>- 本质<br>    - require是赋值过程，其实require的结果就是对象、数字、字符串、函数等，再把require的结果赋值给某个变量<br>    - import是解构过程，但是目前所有的引擎都还没有实现import，我们在node中使用babel支持ES6，也仅仅是将ES6转码为ES5再执行，import语法会被转码为require |
| 11.['1','2','3'].map(parseInt); | - what:[1,NaN,NaN]<br>- why:<br>    - 由于parseInt(*string*, *radix*) 的参数radix必须介于2~36之间，而且字符串string中的数字不能大于radix才能正确返回数字结果值<br>    - map的回调函数的参数index索引值作了parseInt的基数radix，导致出现超范围的radix赋值和不合法的进制解析 |
| 12.写 React / Vue 项目时为什么要在列表组件中写 key，其作用是什么 | - 避免视图更新时的[就地复用]（diff更准确）<br>- 我们可以利用key的唯一性来更快获取到对应节点，比遍历更快。（更快） |
| 13.什么是防抖和节流？有什么区别？如何实现？ | - 防抖是防止重复触发，节流是减少触发次数；<br>- 防抖只执行最后一次；节流每隔指定时间只触发一次<br>- 实现：<br>    - 防抖  每次触发事件时都取消之前的延时调用方法；<br>    - 节流：  每次触发事件时都判断当前是否有等待执行的延时函数（设置标志位，在前一次执行前后改变标志位状态） |
| 14.介绍下 Set、Map、WeakSet 和 WeakMap 的区别？ | - Set<br>    - 成员唯一、无序且不重复<br>    - [value, value]，键值与键名是一致的（或者说只有键值，没有键名）<br>    - 可以遍历，方法有：add、delete、has<br>- WeakSet<br>    - 成员都是对象<br>    - 成员都是弱引用，可以被垃圾回收机制回收，不容易造成内存泄漏<br>    - 不能遍历，方法有add、delete、has<br>- Map<br>    - 本质上是键值对的集合，类似集合<br>    - 可以遍历，方法很多可以跟各种数据格式转换<br>- WeakMap<br>    - 只接受对象作为键名（null除外），不接受其他类型的值作为键名<br>    - 键名是弱引用，键值可以是任意的，键名所指向的对象可以被垃圾回收，此时键名是无效的<br>    - 不能遍历，方法有get、set、has、delete |
| 15.介绍下深度优先遍历和广度优先遍历，如何实现 | - 深度优先遍历（DFS）：  该方法是以纵向的维度对dom树进行遍历，从一个dom节点开始，一直遍历其子节点，直到它的所有子节点都被遍历完毕之后在遍历它的兄弟节点<br>**function**  **deepFirstSearch**(node,nodeList)  {<br>**if**  (node) {<br>nodeList.push(node);<br>**var**  children = node.children;<br>**for**  (**var**  i =  0; i < children.length; i++)<br>//每次递归的时候将 需要遍历的节点 和 节点所存储的数组传下去<br>deepFirstSearch(children[i],nodeList);<br>}<br>**return**  nodeList;<br>}<br>- 广度优先遍历（BFS）：  该方法是以横向的维度对dom树进行遍历，从该节点的第一个子节点开始，遍历其所有的兄弟节点，再遍历第一个节点的子节点，完成该遍历之后，暂时不深入，开始遍历其兄弟节点的子节点。<br>**function**  **breadthFirstSearch**(node)  {<br>**    var**  nodes = [];<br>**    if**  (node !=  null) {<br>**         var**  queue = [];<br>         queue.unshift(node);<br>**         while**  (queue.length !=  0) {<br>**             var**  item = queue.shift();<br>             nodes.push(item);<br>**             var**  children = item.children;<br>**             for**  (**var**  i =  0; i < children.length; i++)<br>                queue.push(children[i]);<br>         }<br>    }<br>**    return**  nodes;<br>} |
| 16.ES5/ES6 的继承除了写法以外还有什么区别 | - **ES5：**的继承实质上是先创建子类的实例对象，然后再将父类的方法添加到this上<br>- **ES6：**的继承机制完全不同，实质上是先创建父类的实例对象this，然后再用子类的构造函数修改this<br>- **ES5**的继承时通过原型或构造函数机制来实现<br>- **ES6**通过class关键字定义类，里面有构造方法，类之间通过extends关键字实现继承 ，**子类**必须在constructor方法中调用super方法，否则新建实例报错 |
| 17.setTimeout、Promise、Async/Await 的区别 | - js是单线程的。<br>- promise被定义后是立即执行的，但是他的resolve是异步的。<br>- promise的异步优先级高于setTimeout。<br>- async会返回一个promise对象，await关键字会让出线程。<br>- promise的resolve是异步的，但它是微任务，而setTimeout虽然也是异步的，但它是宏任务<br>- 同步代码先执行，执行完执行该同步任务的异步微任务，执行完后在执行异步的宏任务<br>- 在没有 await 的情况下执行 async 函数，它会立即执行，返回一个 Promise 对象，并且，绝不会阻塞后面的语句<br>- await 等待的是一个表达式，这个表达式的计算结果是 Promise 对象或者其它值<br>- await 表达式的运算结果取决于它等的东西。<br>    - 如果它等到的不是一个 Promise 对象，那 await 表达式的运算结果就是它等到的东西。<br>    - 如果它等到的是一个 Promise 对象，await 就忙起来了，它会阻塞后面的代码，等着 Promise 对象 resolve，然后得到 resolve 的值，作为 await 表达式的运算结果<br>- 单一的 Promise 链并不能发现 async/await 的优势，但是，如果需要处理由多个 Promise 组成的 then 链的时候，优势就能体现出来了（很有意思，Promise 通过 then 链来解决多层回调的问题，现在又用 async/await 来进一步优化它） |
| 18.Async/Await 如何通过同步的方式实现异步 | - async会将函数包装成一个promise对象返回；<br>- await则会等待后面的表达式结果，并阻塞当前任务，等待后面结果返回会再继续执行当前任务。 |
| 19.写出执行结果<br>async function async1() {<br>console.log('async1 start');<br>await async2();<br>console.log('async1 end');<br>}<br>async function async2() {<br>console.log('async2');<br>}<br>console.log('script start');<br>setTimeout(function() {<br>console.log('setTimeout');<br>}, 0)<br>async1();<br>new Promise(function(resolve) {<br>console.log('promise1');<br>resolve();<br>}).then(function() {<br>console.log('promise2');<br>});<br>console.log('script end'); | 1. script start<br>2. async1 start<br>3. async2;<br>4. promise1;<br>5. script end<br>6. async1 end;<br>7. promise2<br>8. setTimeout |
| 总结& 收获 |
| 重点关注：flexbox布局、闭包、柯里化、async/await |
| 他山之石 |
| *摘录相关精彩书评…* |