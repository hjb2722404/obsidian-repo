汇编语言学习笔记（7）——更灵活地定位内存

# 汇编语言学习笔记（7）——更灵活地定位内存

汇编
1、and指令

	逻辑与指令，按位进行与运算，例如:

	    mov al,01100011B
	    and al,00111011B

计算后的al结果为：00100011B
计算过程：

	 0  1  1  0  0  0  1  1   B
	 0  0  1  1  1  0  1  1   B
	----------------------------
	 0  0  1  0  0  0  1  1   B

> 可以看出，逻辑与运算两个二进制的思路是，设1为真，0为假，则按位对应两个数，同一位置上下两个值同为真则结果为真（1），同为假则结果为假（0），一真一假结果为假（0）；用更简单的结论就是：逻辑与运算中，同一位置只有同为真结果才为真，其它情况均为假。 应用场景：例如，如果要将某个二进制数的第2位（从第0位数起）变为0，则让它与11111011B做逻辑与运算

2、or指令

	逻辑或指令，按位进行或运算，例如：

	    mov al,01100011B
	    or  al,00111011B

计算后的al结果为：01111011
计算过程：

	 0  1  1  0  0  0  1  1   B
	 0  0  1  1  1  0  1  1   B
	----------------------------
	 0  1  1  1  1  0  1  1   B

> 可以看出，逻辑或运算的思路是：相同位置只要有一个为真则结果为真，其他情况结果为假。应用场景：例如，如果要将某个二进制数的第2位（从第0位数起）变为1，则让它与00000100B做逻辑或运算

3、汇编中，我们可以用一对单引号包裹的形式来表示数据是以字符的形式给出的，如：

	dw 'fork word'
	mov 'a'

4、在汇编语言中，可以用[bx+idata]的格式表示一个内存单元，例如：

	mov ax,[bx+200]

此指令的数学表达式为：

	（ax）= ((ds)*16 + (bx)+200)

从上面的示例中我们可以知道，其本质是将内存单元的偏移地址上加了一个常量值。
5、SI和DI在8086CPU中和bx功能相近的寄存器，即都可以存放内存偏移地址。
6、还可以用[bx+si]或[bx+di]的格式来标示内存偏移地址。
7、同样可以使用[bx+si+idata]或[bx+di+idata]的格式表示内存单元偏移地址。

8、在汇编中使用双层嵌套的loop循环时，由于只有一个循环次数计数器cx，所以内层循环的次数会将外层循环次数覆盖，解决办法是在内存循环开始前，将外层循环cx中的数据保存到临时寄存器dx中，在执行外层循环loop命令前在将dx中的数值恢复到cx中；

9、当循环内部程序比较复杂时，仅仅使用寄存器暂存数据远远无法满足程序的需求，这时，就应该开辟一块内存区域来暂时存放数据。而这块区域最好的选择就是定义为栈。
[markdownFile.md](../_resources/bbef6b0cbe4388cf93be8cd97dae361c.bin)