0.1 + 0.2不等于0.3？为什么JavaScript有这种“骚”操作？_精准度

#  0.1 + 0.2不等于0.3？为什么JavaScript有这种“骚”操作？

2018-09-19 18:08 来源:[江苏万和IT教育](https://www.sohu.com/?spm=smpc.content.content.1.1567504176749OilpGCN)

写在前面

随着消费观念的改变，线上消费已经成为大众生活中不可或缺的一部分。在保证消费安全和用户隐私的同时，精准度也是必不可少的一环。试想一下，用户在一款产品上消费，结算金额出错，用户会怎么想？（数体教 or WTF？)，妥妥的差评了吧。 这样不要说用户粘性了，留存都是问题。当Boss得知用户的遭遇后，估计贡献代码的同志会成为前员工或者大家口中的已故员工某某某。

作为一个优秀(laji)的程序员，好久之前就遇到过精确计算的问题，但是偷懒并没有整理出来，直到最近有人问我相关问题，突然觉得有必要写写我对js精确计算的理解

Java中计算的翻车现场

言归正传 书接上文，先来一个简单（landajie）的，展示一下js计算的常规操作

![248fa3221f7740a39134298a78b6a17c.jpeg](https://gitee.com/hjb2722404/tuchuang/raw/master/img/23c5c8b4014596225984e09a6cd73cee.jpg)

这种送分题，js却送了命。令人窒息的操作。这个例子很常见，我们不是为了关注这个例子本身，我们需要明白的是**为什么会出现这样的结果？哪一步出了问题？还有那些计算可能会出现这样的问题？怎么解决？**

**看了评论很多人说：其他遵循 IEEE 754 标准的语言也有这个问题，我知道其他的语言也有，只是这篇文章是以js为切入点，所以不要去纠结语言了，应该关心的是原理本身**

Java是如何表示数字的？

Java使用Number类型表示数字（整数和浮点数），遵循 IEEE 754 标准 通过64位来表示一个数字

通过图片具体看一下数字在内存中的表示

![6de5392c2c424089a50501ed61ae5b54.jpeg](https://gitee.com/hjb2722404/tuchuang/raw/master/img/daf8d3543bb28ded2866541683b9d587.jpg)

图片文字说明

第0位：符号位，0表示正数，1表示负数(s)

第1位到第11位：储存指数部分（e）

第12位到第63位：储存小数部分（即有效数字）f

既然说到这里，再给大家科普一个小知识点：js最大安全数是**Number.MAX_SAFE_INTEGER == Math.pow(2,53) - 1, 而不是Math.pow(2,52) - 1, why？尾数部分不是只有52位吗?**

这是因为二进制表示有效数字总是1.xx…xx的形式，尾数部分f在规约形式下第一位默认为1（省略不写，xx..xx为尾数部分f，最长52位）。因此，Java提供的有效数字最长为53个二进制位（64位浮点的后52位+被省略的1位）

简单验证一下

![70e42591b8144df48e06ddcba698a4cc.jpeg](https://gitee.com/hjb2722404/tuchuang/raw/master/img/7095b05dcbbde6d9a6226a1c3249ea0b.jpg)

运算时发生了什么？

首先，计算机无法直接对十进制的数字进行运算，这是硬件物理特性已经决定的。这样运算就分成了两个部分：**先按照IEEE 754转成相应的二进制，然后对阶运算**

按照这个思路分析一下0.1 + 0.2的运算过程

**1、进制转换**

0.1和0.2转换成二进制后会无限循环

![717774e2ec964706a96f371b9c0f64c8.png](https://gitee.com/hjb2722404/tuchuang/raw/master/img/a426e012c133668785bbe51dc11658eb.png)

但是由于IEEE 754尾数位数限制，需要将后面多余的位截掉（本文借助这个网站直观展示浮点数在内存中的二进制表示）

0.1

![57ff117307574576b3113efab856d769.jpeg](https://gitee.com/hjb2722404/tuchuang/raw/master/img/a88562f4f38272d1bc090b9bfaf01e19.jpg)

0.2

![45d534bcd95c4b92843dc34d28974173.jpeg](https://gitee.com/hjb2722404/tuchuang/raw/master/img/15d00cbe04e5ea52d066a15f9289f05c.jpg)

这样在进制之间的转换中精度已经损失

这里还有一个小知识点

**那为什么 x=0.1 能得到 0.1？**

这是因为这个 0.1 并不是真正的0.1。这不是废话吗？别急，听我解释

标准中规定尾数f的固定长度是52位，再加上省略的一位，这53位是JS精度范围。它最大可以表示2^53(9007199254740992), 长度是 16，所以可以使用 toPrecision(16) 来做精度运算，超过的精度会自动做凑整处理

![de6f7e3f07974ca4affa74624932175c.png](https://gitee.com/hjb2722404/tuchuang/raw/master/img/a991e76ea895f4cb803ba98cac86e98a.png)

这个就是为什么0.1可以等于0.1的原因。好的，继续

**2、对阶运算**

由于指数位数不相同，运算时需要对阶运算 这部分也可能产生精度损失

按照上面两步运算（包括两步的精度损失），最后的结果是

结果转换成十进制之后就是0.30000000000000004，这样就有了前面的“秀”操作：0.1 + 0.2 != 0.3

所以：

**精度损失可能出现在进制转化和对阶运算过程中**

**精度损失可能出现在进制转化和对阶运算过程中**

**精度损失可能出现在进制转化和对阶运算过程中**

只要在这两步中产生了精度损失，计算结果就会出现偏差

怎么解决精度问题？

**1、将数字转成整数**

这是最容易想到的方法，也相对简单

![020aad309dd940ac8a9d9debb72c88da.png](https://gitee.com/hjb2722404/tuchuang/raw/master/img/0002166a43747558bdc707113f8cddd8.png)

但是这种方法对大数支持的依然不好

**2、三方库**

这个是比较全面的做法，推荐2个我平时接触到的库

① Math.js

专门为 Java 和 Node.js 提供的一个广泛的数学库。支持数字，大数字(超出安全数的数字)，复数，分数，单位和矩阵。 功能强大，易于使用。

官网：http://mathjs.org/

GitHub：https://github.com/josdejong/mathjs

② big.js

官网：http://mikemcl.github.io/big.js

GitHub：https://github.com/MikeMcl/big.js/

③若干，不一一列举了

这几个类库都很牛逼，可以应对各种各样的需求，不过很多时候，一个函数能解决的问题不需要引用一个类库来解决。

以上就是我对js精准计算的理解，希望可以帮到大家

来源：掘金

作者：Gladyu

原文链接：https://juejin.im/post/5b90e00e6fb9a05cf9080dff[返回搜狐，查看更多](https://www.sohu.com/?strategyid=00001&spm=smpc.content.content.2.1567504176749OilpGCN)

声明：该文观点仅代表作者本人，搜狐号系信息发布平台，搜狐仅提供信息存储空间服务。
