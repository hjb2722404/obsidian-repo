前端面试经验（二）

|     |
| --- |
| **前端面试记录（二）** |
| 面试问题 |
| 1.前一个公司业务/组织架构；2.你在这种架构中的角色/任务 |
| 问题  | 答案  |
| 1.CSS内容大小不固定垂直居中方案 | - 第一种与固定宽高垂直居中一样，但是用translate百分比代替margin<br>- 第二种是用CSS3的方式，在父级元素上加：<br>    - justify-content:center;//子元素水平居中<br>    - align-items:center;//子元素垂直居中<br>    - display:-webkit-flex;<br>- 前两种不支持IE8<br>- 第三种是利用margin:auto，方法是父元素固定定位，子元素绝对定位，子元素上下左右都设为0，宽高设为50%，margin设为auto，可兼容IE8 |
| 2.表格固定几列滚动后保持对齐方案； | table tbody {<br>display:block;<br>height:195px;<br>overflow-y:scroll;<br>}<br>table thead, tbody tr {<br>display:table;<br>width:100%;<br>table-layout:fixed;<br>}<br>table thead {<br>width: calc( 100% - 1em )<br>}<br>table thead th{ background:#ccc;} |
| 3.js数组去重 | - 新建一个数组，遍历去要重的数组，当值不在新数组的时候（indexOf为-1）就加入该新数组中；<br>- 双层循环，外循环表示从0到arr.length，内循环表示从i+1到arr.length。将没重复的右边值放入新数组。（检测到有重复值时终止当前循环同时进入外层循环的下一轮判断）<br>- ES6提供了新的数据结构Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。Set函数可以接受一个数组（或类似数组的对象）作为参数，用来初始化。 |
| 已知如下数组：<br>var arr = [ [1, 2, 2], [3, 4, 5, 5], [6, 7, 8, 9, [11, 12, [12, 13, [14] ] ] ], 10];<br>编写一个程序将数组扁平化去并除其中重复部分数据，最终得到一个升序且不重复的数组 | 数组扁平化：<br>- 数组适用toString()方法后变成以逗号分割（split）的字符串，然后map遍历数组把每一项再变回整数并返回map后的结果。[toString+split+map]<br>- 循环数组，如果数据中还有数组的话，递归调用flatten扁平函数（利用for循环扁平），用concat连接，最终返回result;[for-递归-concat] |
| JS 异步解决方案的发展历程以及优缺点 | 1. 回调函数。<br>    1. 例如setTimeOut和ajax<br>    2. 优点：js发展早期解决了同步等待问题<br>    3. 缺点：思维错序、控制反转、无法捕获错误<br>2. promise<br>    1. 解决了回调地域问题，可链式调用<br>    2. 无法取消promise，错误需要回调捕获<br>3. 生成器（generator）<br>    1. 符合大脑逻辑顺序<br>    2. 可按步前进，更好的控制<br>4. Async/await<br>    1. 代码清晰，不需要一大堆then链<br>    2. await将异步改造为同步，如果多个异步没有依赖性而使用await会导致性能上的降低。 |
| Promise 构造函数是同步执行还是异步执行，那么 then 方法呢？ | - 构造函数是同步执行<br>- then方法是异步微任务 |
| 如何实现一个 new | 1.创建一个空对象<br>2.链接到原型<br>3.绑定this值<br>4.返回新对象<br>function  create(){<br>//创建一个空对象<br>let  obj  =  new  Object();<br>//获取构造函数<br>let  Constructor  =  [].shift.call(arguments);<br>//链接到原型<br>obj.__proto__  =  Constructor.prototype;<br>//绑定this值<br>let  result  =  Constructor.apply(obj,arguments);//使用apply，将构造函数中的this指向新对象，这样新对象就可以访问构造函数中的属性和方法<br>//返回新对象<br>return  typeof  result  ===  "object"  ?  result  :  obj;//如果返回值是一个对象就返回该对象，否则返回构造函数的一个实例对象} |
| 简单讲解一下http2的多路复用 | - Keep-Alive:一定时间内，同一域名下的多次请求数据，只建立一次HTTP连接<br>- HTTP1.1存在的问题：<br>    - 串行的文件传输，并且必须按序传输<br>    - 连接数过多，浏览器对最大连接数的限制（6个）<br>- HTTP/2 引入二进制数据帧与流，做到并行乱序传输，也同样基于流，同一 域名只建立一路连接，所有请求都通过这一路流来传输。<br>    - 一个连接同时被多个流复用；<br>    - 一个流代表一次完整的请求/响应过程，包含多个帧；<br>    - 一个消息被拆分封装成多个帧进行传输 |
| 谈谈你对TCP三次握手和四次挥手的理解 | - 三次握手<br>    - B->S: SYN=1,Seq=x<br>    - S->B: SYN=1,ACK=1,seq=y,ack=x+1<br>    - B->S: ACK=1,seq=x+1,ack=y+1<br>    - S->B: 开始传送数据<br>- 四次挥手<br>    - B->S：FIN=1,seq=u<br>    - S->B:  ACK = 1,seq=v,ack=u+1<br>    - S->B: 传送剩余数据<br>    - S->B:  FIN=1,ACK=1,seq=w,ack=u+1<br>    - B->S: ACK=1,seq=u+1,ack=w+1 |
| A、B 机器正常连接后，B 机器突然重启，问 A 此时处于 TCP 什么状态 | 因为B会在重启之后进入tcp状态机的listen状态，只要当a重新发送一个数据包（无论是syn包或者是应用数据），b端应该会主动发送一个带rst位的重置包来进行连接重置，所以a应该在syn_sent状态 |
| React 中 setState 什么时候是同步的，什么时候是异步的？ | 在 React 中，如果是由 React 引发的事件处理（比如通过 onClick 引发的事件处理），调用 setState 不会同步更新 this.state，除此之外的 setState 调用会同步执行 this.state。所谓“除此之外”，指的是绕过 React 通过 addEventListener 直接添加的事件处理函数，还有通过 setTimeout/setInterval 产生的异步调用 |
| 介绍下 npm 模块安装机制，为什么输入 npm install 就可以自动安装对应的模块 | ### **NPM 模块安装机制****：**<br>- 发出npm install命令<br>- 查询node_modules目录之中是否已经存在指定模块<br>- 若存在，不再重新安装<br>- 若不存在<br>    - npm 向 registry 查询模块压缩包的网址<br>    - 下载压缩包，存放在根目录下的`.npm`目录里<br>    - 解压压缩包到当前项目的`node_modules`目录<br>### 2. NPM 实现原理<br>- 输入 npm install 命令并敲下回车后，会经历如下几个阶段（以 npm 5.5.1 为例）：<br>- 执行工程自身 preinstall<br>- 确定首层依赖模块<br>- 获取模块  获取模块是一个递归的过程，分为以下几步：<br>- 获取模块信息。<br>- 获取模块实体。<br>- 查找该模块依赖，如果有依赖则回到第1步，如果没有则停止。<br>- 模块扁平化（dedupe）<br>- 安装模块<br>- 执行工程自身生命周期<br>- 最后一步是生成或更新版本描述文件，npm install 过程完成。 |
| Object.prototype.toString.call() 、 instanceof 以及 Array.isArray()<br>区别于优劣 | - toString方法只有当Object类型调用时才会返回对象类型，其他类型会返回内容字符串<br>    - 这种方法对于所有基本的数据类型都能进行判断，即使是 null 和 undefined<br>    - Object.prototype.toString.call() 常用于判断浏览器内置对象<br>- instanceof  的内部机制是通过判断对象的原型链中是不是能找到类型的 prototype。<br>    - 但 instanceof 只能用来判断对象类型，原始类型不可以。并且所有对象类型 instanceof Object 都是 true<br>- isArray   用来判断对象是否为数组<br>    - 当检测Array实例时，Array.isArray 优于 instanceof ，因为 Array.isArray 可以检测出 iframes<br>    - Array.isArray()是ES5新增的方法，当不存在 Array.isArray() ，可以用 Object.prototype.toString.call() 实现 |
| 重绘和回流（Repaint & Reflow），以及如何进行优化 | - 当页面中的部分或者全部元素改变宽度和高度、或者位置发生变化、删除或者增加某个或者某些元素时、某个元素影藏或者显示时，这时页面就需要重新加载了，这就叫做回流。<br>- 当页面的中的可见性发上变化时，比如：背景颜色吗，文字颜色等，这样就形成了重绘。<br>- 从上面可以看出，回流必将引起重绘，而重绘不一定会引起回流<br>- 优化<br>    - 使用cssText属性，  使用cssText时应该采用叠加的方式以保留原有的样式<br>    - 不要一条条的修改DOM属性，可以预先定义好CSS的Class，然后修改DOM的ClassName<br>    - 避免使用table布局<br>    - 尽可能在DOM树的最末端改变class。<br>    - 避免设置多层内联样式<br>    - 将动画效果应用到position属性为absolute或fixed的元素上<br>    - 避免使用CSS表达式<br>    - 避免频繁操作DOM，创建一个documentFragment，在它上面应用所有DOM操作，最后再把它添加到文档中<br>    - 也可以先为元素设置display: none，操作结束后再把它显示出来。因为在display属性为none的元素上进行的DOM操作不会引发回流和重绘<br>    - 避免频繁读取会引发回流/重绘的属性，如果确实需要多次使用，就用一个变量缓存起来<br>    - 对具有复杂动画的元素使用绝对定位，使它脱离文档流，否则会引起父元素及后续元素频繁回流 |
| 浏览器解析大概的工作流程大致可归纳为**四个步骤** | **1.解析HTML以构建DOM树**：渲染引擎开始解析HTML文档，转换树中的html标签或[js](http://lib.csdn.net/base/javascript)生成的标签到DOM节点，它被称为 – 内容树。<br>2. **构建渲染树**：解析CSS（包括外部CSS文件和样式元素以及js生成的样式）成样式结构体，根据CSS选择器计算出节点的样式，创建另一个树 —- 渲染树（render tree）。<br>*注：在解析的过程中会去掉浏览器不能识别的样式，比如IE会去掉-moz开头的样式，而firefox会去掉_开头的样式。*<br>3. **布局渲染树**: 从根节点递归调用，计算每一个元素的大小、位置等，给每个节点所应该出现在屏幕上的精确坐标。<br>4. **绘制渲染树**: 遍历渲染树，每个节点将使用UI后端层来绘制。 |
| 观察者模式和订阅-发布模式的区别，各自适用于什么场景 | - 观察者模式中主体和观察者是互相感知的，发布-订阅模式是借助第三方来实现调度的，发布者和订阅者之间互不感知<br>- 发布-订阅模式是观察者模式的一种变体。发布-订阅只是把一部分功能抽象成一个独立的ChangeManager<br>- 总的来说，发布-订阅模式适合更复杂的场景。<br>    - 在「一对多」的场景下，发布者的某次更新只想通知它的部分订阅者？<br>    - 在「多对一」或者「多对多」场景下。一个订阅者依赖于多个发布者，某个发布者更新后是否需要通知订阅者？还是等所有发布者都更新完毕再通知订阅者？<br>    - 这些逻辑都可以放到ChangeManager里。 |
| ### **Redux 和 Vuex 的设计思想** | ###### **Redux**<br>- 核心对象：store<br>- 数据存储：state<br>- 状态更新提交接口：dispatch<br>- 状态更新提交参数：带type和payload的Action<br>- 状态更新计算：reducer<br>- 限制：reducer必须是纯函数，不支持异步<br>- 特性：支持中间件<br>VUEX<br>- 核心对象：store<br>- 数据存储：state<br>- 状态更新提交接口：commit<br>- 状态更新提交参数：带type和payload的mutation提交对象/参数<br>- 状态更新计算：mutation handler<br>- 限制：mutation handler必须是非异步方法<br>- 特性：支持带缓存的getter，用于获取state经过某些计算后的值<br>区别：<br>- VUEX弱化了dispatch的存在感<br>- VUEX取消了Redux中Action的概念<br>- **VUEX也弱化了Redux中的reducer的概念**<br>- VUEX支持getter，运行中是带缓存的 |
| 前后端分离的优缺点 | 优点：<br>- 减轻服务器的请求和渲染压力<br>- 解决后端工程师无法专注后端业务逻辑问题（因为要将静态html转换为动态页面，涉及css和js问题需要与前端协同开发）<br>- 解决了应用前端无法利用更高效的静态服务器的问题；<br>- 前后端可以使用各自专业的IDE，提升开发效率；<br>- 解决了前后端的流程依赖问题（即后端工程师必须等待前端工程师的html页面做好后才能将其转化为动态页面，前端如果发生样式或逻辑改变，后端也必须返工），可以并行开发<br>- 可以更快速和精确地定位问题，不会出现互相踢皮球的现象。<br>- 后端某个服务出问题不会影响到前端整体呈现，只会有部分数据无法显示而已<br>- 前端独立出来后更好地实现模块化、组件化和工程化。<br>- 可以实现后台一套接口支持前端多种终端共用<br>缺点：<br>- 加重了客户端的压力<br>- 异步请求的增多容易造成用户体验的下降<br>- SEO问题<br>- 小项目浪费人员配置成本 |
| promise的实现思路 | - Promise是一个函数或者对象<br>- 必须实现then方法；<br>- 要有一个变量来存储promise的状态，pending/fulfilled/rejected，并且状态只能由pending变为另外两个<br>- 当状态变为fulfilled之后，必须有一个value（终值）,并且不能改变<br>- 当状态变为rejected之后，必须有一个reason(拒因)<br>- then方法可接收两个参数，onFulfilled和onRejected，这两个函数必须在promise完成之后（即pending改变Wie为另两个状态之后）执行，并且第一个参数是终值或拒因，这两个方法要放在在setTimeout中执行，并且只能执行一次，这要求有个变量来存放这两个函数的执行状态（已执行/未执行）<br>- 需要两个队列（数组实现）来分别存放onFulfilled和onRejected的回调函数，在promise完成之后，根据状态依次执行其中一个队列中的所有回调；<br>- then方法可以被同一个promise调用多次: 返回this;<br>- 实现一个reslove方法和一个reject方法； |
| 前端安全问题 | - XSS-脚本攻击漏洞<br>    - 如果使用HTML进行内容转换，则使用innerText而不用innerHTML,或者把script、iframe标签过滤替换掉<br>    - 对一些标签的字符串进行转移<br>- CSRF-跨站请求伪造<br>    - 增加token验证；<br>    - Referer页面来源验证（后端）；<br>- iframe安全隐患<br>    - 使用安全的网站进行嵌入<br>    - 在iframe上添加 sandbox 属性<br>- 本地存储数据问题<br>    - 对本地存储的信息进行加密<br>- 第三方依赖安全隐患<br>    - 利用自动化工具扫描第三方插件（如NSP）<br>- HTTP安全隐患<br>    - 对服务器加HTTPS |
| 说说浏览器和 Node 事件循环的区别 | - 规范不同<br>    - 浏览器时间循环基于HTML5规范实现，<br>    - 而Node中的时间循环基于libuv库实现<br>- 任务队列不同<br>    - 浏览器中的任务分为宏任务和微任务队列（同步任务也属于宏任务，宏任务队列可以有多个，微任务队列只有一个）。<br>    - 而Node环境中的任务类型则包括定时器队列、I/O任务，check任务（执行setimmediate的回调）,close任务（关闭所有closing handles和一些onclose事件），nextTick任务和微任务队列等<br>- 执行过程不同<br>    - 浏览器的执行过程是先执行同步任务，然后执行微任务，然后执行宏任务，每次执行完宏任务都会去检查一下微任务队列，如果有任务，就执行全部微任务；如此循环。<br>    - 而Node中则是依照外部输入数据-->轮询阶段（获取新的I/O事件）->检查阶段（执行setImmediate回调）->关闭事件回调阶段->定时器检测阶段（执行定时器回调）->I/O事件回调阶段->闲置阶段->轮询阶段，如此循环； |
| ### **介绍模块化发展历程** | - 一开始，全部代码都写在全局作用域中，于是出现了命名冲突的问题；<br>- 然后开始开发人员将各自的模块代码放入立即执行函数中，解决了命名冲突问题。但随着模块增多，全局的模块命名变量还是有可能冲突<br>- jquery风格的匿名自执行函数，解决了依赖模块的传递问题，虽然灵活，但未从根本上解决以上问题<br>- CommonJS出现，通过全局的require和exports来管理模块及其依赖，解决了全局作用域变量污染问题和依赖传递问题，但它是同步的，无法用于浏览器端；<br>- AMD出现（requirejs），实现了模块的异步加载和对浏览器的支持。但出现了模块代码被预先执行的问题。<br>- CMD（sea.js）,定义模块时无需再罗列依赖数组，代码会预先下载但不会预先执行<br>- ES6模块：实现了编译时确定依赖关系，并且可以指定加载模块中用export暴露的接口，没指定的就不会加载 |
| ### **全局作用域中，用 const 和 let 声明的变量不在 window 上，那到底在哪里？如何去获取？** | - 在一个块级作用域中<br>- 在所属块级作用域中调用即可获取 |
| ### **cookie 和 token 都存放在 header 中，为什么不会劫持 token？** | - token是防止跨站请求伪造的<br>- 因为浏览器进行信息提交时会自动带上cookie，给了伪造请求者可乘之机<br>- 而浏览器不会自动带上token，所以即使伪造者伪造了请求，也无法通过后端验证 |
| ### **聊聊 Vue 的双向数据绑定，Model 如何改变 View，View 又是如何改变 Model 的** | - 利用Object.defineproperty方法来实现数据劫持<br>- 观察者模式实现双向的监听和更新（由于每一个属性都有多个观察者对其观察，所以是观察者模式不是发布-订阅模式）<br>- 通过一个监听器Observer来监听属性的变化并通知观察者<br>    - 监听的实现是通过在oberver中对数据属性递归执行defineproperty方法来对数据进行劫持<br>    - 在访问器属性set中完成向观察者通知的操作<br>- 通过一个观察者Watcher来接收通知并更新视图<br>- 通过一个Compile解析器，来解析指令、初始化模板，绑定订阅者（负责更新视图）【借助文档碎片实现，减少DOM操作】 |
| 总结& 收获 |
| *读完每一本书，把书中的知识转化为「自己的智慧」，才是最扎实的收获…* |
| 他山之石 |
| *摘录相关精彩书评…* |