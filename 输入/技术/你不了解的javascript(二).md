你不了解的javascript(二)

# 你不了解的javascript(二)

## this和对象原型续

- 在js中，类只是一种设计模式，它只是一种近似于类的语法，和其他语言中的类并不一样
- 类的底层数据结构是栈
- 类通过复制操作被实例化为对象；
- javascript的实例化和继承不是通过复制完成的，而是通过原型。
- 由于javascript中不存在类，所以我们模拟的类实际上只是对象，而继承和实例化只是对象到对象的关联操作，可以称之为“混入”（mixin）;
- 通过 call() 方法来实现显式多态，但应该尽量避免使用这种多态。
- 对象进行属性设置（obj.propertyName = value）时会有三种情况
    - 如果对象中包含该名称的【普通数据访问属性】,会修改已有属性值
    - 如果该属性即不存在与对象中，也不存在于原型链上层，会直接为该对象添加新属性并赋值
    - 如果该属性不在对象中，而是存在于原型链上层，会有三种情况：
        - 如果原型链上层存在该名称的【普通数据访问属性】，并且非只读，会在对象上添加一个该名称的属性，它是屏蔽属性
        - 如果原型链上层存在该属性，并且是只读，严格模式下会抛出错误，非严格模式下该语句被忽略
        - 如果在原型链上层存在该属性，且它是一个setter，就会调用这个setter。
    - ++ 操作会产生隐式屏蔽。
- 在js中没有类似其它具有【类】的语言的那种复制机制，js中模拟的类实例化只是创建一个新对象，并且将它的[[Prototype]]属性关联到被定义为“类”的那个对象的 prototype 属性上。
- 继承意味着复制操作，JavaScript（默认）并不会复制对象属性
- 委托这个术语可以更加准确地描述JavaScript中对象的关联机制。
- new 会劫持所有普通函数并用[构造对象]的形式来调用它
- new 出的对象并没有 constructor属性，而只是委托给了被当做“类”的那个对象（函数）。
- constructor并不表示被构造
- 调用 Object.create(..) 会凭空创建一个“新”对象并把新对象内部的 [[Prototype]] 关联到你指定的对象
- ES6添加了辅助函数 Object.setPrototypeOf(..) ，可以用标准并且可靠的方法来修改关联
- `.__proto__` 看起来很像一个属性，但是实际上它更像一个getter/setter

## 类型和语法

- 函数与数组都是对象的子类型，函数有length属性，就是参数个数
- js中的变量没有类型，只有值才有类型。变量可以随时持有不同类型的值
- js中typeof针对未声明与已声明但未赋值的变量均返回`undefined`
- 检测一个值是否为null，利用null为假值的特性：

	var a = null;
	(!a && typeof a === "object")

- js中的安全防范机制：使用前先用typeof检测是否为“undefined”,可以阻止未声明报错
- 使用 delete 运算符可以将单元从数组中删除，但是请注意，单元删除后，数

组的 length 属性并不会发生变化。被删除的位置使用时会返回`undefined`;

- 数组也是对象，所以也可以使用字符串键值和属性，但它们不会被计算到数组长度内；
- 将类数组转换为真数组：

	Array.prototype.slice.call(arr)

- 典型的类数组：NodeList（DOM节点列表），arguments（函数参数列表）
- 尽管js中的字符串很多行为像数组，但字符串是不可变的，而数组是可变的，所以字符串的成员函数对字符串进行改变操作时会返回新的字符串，而数组的成员函数则返回原数组。
- 数组push 操作会返回操作后的数组长度
- 字符串可以通过 call() 借用数组的成员方法，但不可以借用数组的可变更成员函数
- js中的数字前面的0和小数部分最后面的0可以省略
- **.** 在数字前后时会被优先识别为数字常量的一部分，然后才是对象属性访问云算符，在调用数字的成员方法时要格外注意；
- 数字计算时允许的误差范围值（机器精度）： 2的负52次方，js 的最大浮点数：1.798e+308，最小浮点数：5e-324

