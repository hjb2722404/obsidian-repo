你不了解的javascript（三）

# 你不了解的 javascript（三）

## 类型和语法(续)

- 能够被“安全”呈现的最大整数是 2^53 - 1 ，即 9007199254740991，最小整数是 -9007199254740991
- 由于JavaScript 的数字类型无法精确呈现 64 位数值，所以必须将它们保存（转换）为字符串
- 整数检测：

	return typeof num == "number" && num % 1 == 0;

- a | 0 可以将变量 a 中的数值转换为 32 位有符号整数，因为数位运算符 | 只适用于 32 位

整数

- undefined 和 null 既是它们自己的名称也是它们唯一的值，null指空值，undefined指没有指
- void 0 、 void 1 和 undefined 之间并没有实质上的区别
- 如果要将代码中的值（如表达式的返回值）设为 undefined ，就可以使用 void
- 如果数学运算的操作数不是数字类型（或者无法解析为常规的十进制或十六进制数字），就无法返回一个有效的数字，这种情况下返回值为 NaN
- NaN 是一个特殊值，它和自身不相等，是唯一一个非自反（自反，reflexive，即 x === x 不

成立）的值。

- ES6之前判断值是否是NaN:

	if (!Number.isNaN) {
	    Number.isNaN = function(n) {
	        return (
	            typeof n === "number" &&
	            window.isNaN( n )
	        );
	    };
	}
	// 或者
	if (!Number.isNaN) {
	    Number.isNaN = function(n) {
	    return n !== n;
	    };
	}

- -0 除了可以用作常量以外，也可以是某些数学运算的返回值
- 加法和减法运算不会得到负零（negative zero），根据规范，对负零进行字符串化会返回 "0" ：
- JSON.stringify(-0) 返回 "0" ，而 JSON.parse("-0") 返回 -0
- ES6之前，判断两个值(特殊等值)是否相等：

	if (!Object.is) {
	    Object.is = function(v1, v2) {
	    // 判断是否是-0
	    if (v1 === 0 && v2 === 0) {
	        return 1 / v1 === 1 / v2;
	    }
	    // 判断是否是NaN
	    if (v1 !== v1) {
	        return v2 !== v2;
	    }
	    // 其他情况
	    return v1 === v2;
	    };
	}

- 在 JavaScript 中变量不可能成为指向另一个变量的引用。JavaScript 引用指向的是值
- 简单值（即标量基本类型值，scalar primitive）总是通过值复制的方式来赋值 / 传递，包括null 、 undefined 、字符串、数字、布尔和 ES6 中的 symbol
- 复合值（compound value）——对象（包括数组和封装对象，参见第 3 章）和函数，则总是通过引用复制的方式来赋值 / 传递
- 虽然 Null() 和 Undefined() 这样的原生构造函数并不存在，但是内部 [[Class]] 属性值仍然是 "Null" 和 "Undefined"
- 在需要用到封装对象中的基本类型值的地方会发生隐式拆封
- 我们将包含至少一个“空单元”的数组称为“稀疏数组”。
- 总之，永远不要创建和使用空单元数组
- 除非万不得已，否则尽量不要使用 Object(..) / Function(..) / RegExp(..) ：
- JavaScript 中的强制类型转换总是返回标量基本类型值（参见第 2 章），如字符串、数字和布尔值，不会返回对象和函数
- JSON.stringify(..) 在对象中遇到 undefined 、 function 和 symbol 时会自动将其忽略，在数组中则会返回 null
- 基本类型值的字符串化规则为： null 转换为 "null" ， undefined 转换为 "undefined" ， true转换为 "true" 。数字的字符串化则遵循通用规则
- 如果对象有自己的 toString() 方法，字符串化时就会调用该方法并使用其返回值
- 数组的默认 toString() 方法经过了重新定义，将所有单元字符串化以后再用 "," 连接起来
- 所有安全的 JSON 值（JSON-safe）都可以使用 JSON.stringify(..) 字符串化。安全的JSON 值是指能够呈现为有效 JSON 格式的值
- 如果对象中定义了 toJSON() 方法，JSON 字符串化时会首先调用该方法，然后用它的返回值来进行序列化，toJSON() 应该“返回一个能够被字符串化的安全的 JSON 值”
- 我们可以向 JSON.stringify(..) 传递一个可选参数 replacer，它可以是数组或者函数，用来指定对象序列化过程中哪些属性应该被处理，哪些应该被排除
    - 如果 replacer 是一个数组，那么它必须是一个字符串数组，其中包含序列化要处理的对象的属性名称，除此之外其他的属性则被忽略
    - 如果 replacer 是一个函数，它会对对象本身调用一次，然后对对象中的每个属性各调用一次，每次传递两个参数，键和值。如果要忽略某个键就返回 undefined ，否则返回指定的值

	var a = {
	    b: 42,
	    c: "42",
	    d: [1,2,3]
	    };
	JSON.stringify( a, ["b","c"] ); // "{"b":42,"c":"42"}"
	JSON.stringify( a, function(k,v){
	    if (k !== "c") return v;
	} );  // "{"b":42,"d":[1,2,3]}"

- JSON.string 还有一个可选参数 space，用来指定输出的缩进格式。space 为正整数时是指定每一级缩进的字符数，它还可以是字符串，此时最前面的十个字符被用于每一级的缩进
- JSON.stringify(..) 并不是强制类型转换
- 将非数字值当作数字来使用, true 转换为 1 ， false 转换为 0 。 undefined 转换为 NaN ， null 转换为 0
- 抽象操作 ToPrimitive （参见 ES5 规范 9.1 节）会首先检查该值是否有 valueOf() 方法。如果有并且返回基本类型值，就使用该值进行强制类型转换。如果没有就使用 toString()的返回值（如果存在）来进行强制类型转换,如果 valueOf() 和 toString() 均不返回基本类型值，会产生 TypeError 错误
- JavaScript 中的值可以分为以下两类：
    - (1) 可以被强制类型转换为 false 的值
    - (2) 其他（被强制类型转换为 true 的值）
    - 以下这些是假值,假值的布尔强制类型转换结果为 false

• undefined
• null
• false
• +0 、 -0 和 NaN
• ""

- 假值列表以外的值都是真值
- 假值对象看起来和普通对象并无二致（都有属性，等等），但将它们强制类型转换为布尔值时结果为 false,最常见的例子是 document.all

-

    - 运算符显式地将 c 转换为数字，而非数字加法运算
- 一元运算符 - 和 + 一样，并且它还会反转数字的符号位
- 一元运算符 + 的另一个常见用途是将日期（ Date ）对象强制类型转换为数字，返回结果为Unix 时间戳，以微秒为单位
- 字位运算符（如 |和 ~ ）和某些特殊数字一起使用时会产生类似强制类型转换的效果，返回另外一个数字
    - 例如 | 运算符（字位操作“或”）的空操作（no-op） 0 | x ，它仅执行 ToInt32 转换
    - 再回到 ~ 。它首先将值强制类型转换为 32 位数字，然后执行字位操作“非”（对每一个字位进行反转）
    - ~ 和 indexOf() 一起可以将结果强制类型转换（实际上仅仅是转换）为真 / 假值
- 解析允许字符串中含有非数字字符，解析按从左到右的顺序，如果遇到非数字字符就停止。而转换不允许出现非数字字符，否则会失败并返回 NaN
- parseInt(1/0, 19) 实际上是 parseInt("Infinity", 19) 。第一个字符是 "I" ，以 19 为基数时值为 18 。第二个字符 "n" 不是一个有效的数字字符，解析到此为止，和 "42px" 中的 "p"一样
- 一元运算符 ! 显式地将值强制类型转换为布尔值。但是它同时还将真值反转为假值
- 因为数组的valueOf() 操作无法得到简单基本类型值，于是它转而调用 toString()
- 如果 + 的其中一个操作数是字符串（valueOf--toString），则执行字符串拼接；否则执行数字加法
- 根据ToPrimitive 抽象操作规则， a + "" 会对 a 调用 valueOf() 方法，然后通过 ToString 抽象操作将返回值转换为字符串。而 String(a) 则是直接调用 ToString()

-

    - 是数字减法运算符，因此 a - 0 会将 a 强制类型转换为数字
- 下面的情况会发生布尔值隐式强制类型转换
    - if (..) 语句中的条件判断表达式
    - for ( .. ; .. ; .. ) 语句中的条件判断表达式（第二个）。
    - while (..) 和 do..while(..) 循环中的条件判断表达式
    - ? : 中的条件判断表达式
    - 逻辑运算符 || （逻辑或）和 && （逻辑与）左边的操作数（作为条件判断表达式）
- && 和 || 运算符的返回值并不一定是布尔类型，而是两个操作数其中一个的值
    - || 和 && 首先会对第一个操作数执行条件判断，如果其不是布尔值就先进行 ToBoolean 强制类型转换，然后再执行条件判断
    - 对于 || 来说，如果条件判断结果为 true 就返回第一个操作数的值，如果为false 就返回第二个操作数的值
    - && 则相反，如果条件判断结果为 true 就返回第二个操作数的值，如果为 false 就返回第一个操作数的值
- == 允许在相等比较中进行强制类型转换，而 === 不允许
- == 两边的布尔值会被强制类型转换为数字
- a == null 这样的隐式强制类型转换在保证安全性的同时还能提高代码可读性
- == 比较中，字符串和布尔值总会被转换为数字，对象会转换为字符串后再转换为数字

