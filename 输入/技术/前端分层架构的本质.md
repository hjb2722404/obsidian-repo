# 前端分层架构的本质

## 1. 前端架构演进

### 1.早期-前后一体化架构

* 前后端杂糅在一起，ASP/JSP/PHP文件中既包含后端代码，也包含前端代码。

  ![img](https://images2018.cnblogs.com/blog/1391717/201806/1391717-20180625202356780-964264019.png)



### 2. 后端MVC架构

* 界面层单独解耦出来，但代码还是写在PHP/JSP/ASP文件中，但已经将后端逻辑移到了Controller和Model中，前端只是利用插值语法和条件判断来展示数据（类似于MVVM架构中的view层）

  ![img](https://images2018.cnblogs.com/blog/1391717/201806/1391717-20180625203813407-1294099977.png)

### 3. 前后端分离MVC

* Ajax技术的出现，使得前端代码不必再写在动态脚本语言中，而是可以直接写在HTML中了。前端负责V，后端负责MC

  ![img](https://images2018.cnblogs.com/blog/1391717/201806/1391717-20180625204652938-408887818.png)

### 4. 前端进一步分层（前端MVC）

* 前端的V这一层内部进一步进行分层，分为了视图与交互逻辑（V）、数据请求与处理逻辑（M），业务逻辑（C）三层。

![img](https://images2018.cnblogs.com/blog/1391717/201806/1391717-20180625222414836-1421027844.png)

![img](https://images2018.cnblogs.com/blog/1391717/201806/1391717-20180625205307984-361897520.png)

### 5. 前端MVVM

* 由于前端MVC架构中，V层逻辑需要频繁操作DOM，操作DOM十分麻烦，所以又出现了双向绑定技术，让DOM与页面状态数据进行绑定联动，省去了大部分操作DOM的工作。进行绑定的这一层为ViewModel层（VM），代替了原来的C层。

  ![img](https://images2018.cnblogs.com/blog/1391717/201806/1391717-20180625210057645-204518132.png)

## 2. 目前的困境

* 在前端MVVM架构流行后，先后出来了angular/react/vue三种十分流行的MVVM框架
* 框架的流行在减轻了程序员初次工作量的同时，却也使得程序员们陷入了对框架强依赖的陷阱中，尤其是当这些框架不再流行，需要更换一种框架时，由于框架架构与语法的限制，在迁移框架时几乎要把系统重新写一遍，而无法复用原来的代码，从而带来了巨大的工作量。
* 而众所周知，前端的变化非常快，几乎没几年就会流行新的框架，这就导致后面新的程序员维护老系统的成本非常高，不得不使用新技术重写时成本也非常高。

## 3. 解决的思路

* 既然前端变化非常快，那么就要尽量在变化中寻找不变的部分。
* 借鉴后端的领域模型驱动的思想，前端其实也有基本不会变的部分——业务。业务又可以划分为多个业务领域。
* 而数据与业务是息息相关的，只要业务不变，数据的结构也就不会变，即使业务收缩或扩张，那变化的部分也是极小的，修改的代价可以非常低。
* 回归前端的本质，不管框架怎么变，框架语法怎么限制，最终产物都是HTML+CSS+JS。
* 基于以上问题与思路，出现了一种新的前端分层架构模式——整洁架构
  * 框架无关性。系统不依赖于框架中的某个函数，框架只是一个工具，**系统不能适应于框架**。
  * 可被测试。业务逻辑脱离于 UI、数据库等外部元素进行测试。
  * UI 无关性。不需要修改系统的其它部分，就可以变更 UI，诸如由 Web 界面替换成 CLI。
  * 数据库无关性。业务逻辑与数据库之间需要进行解耦，我们可以随意切换 LocalStroage、IndexedDB、Web SQL。
  * 外部机构（agency）无关性。系统的业务逻辑，不需要知道其它外部接口，诸如安全、调度、代理等。

![img](https://pic2.zhimg.com/80/v2-75b33baf375f011a5d8f53dd01e120b1_720w.jpg)

![preview](https://cdn.jsdelivr.net/gh/hjb2722404/myimg/20210119135005.jpeg)

但整洁架构的层级过多，逻辑过于复杂，在个人理解基础上，优化得出以下结论：

* 业务领域代码、数据请求代码、公共工具和服务等都是变化较小的部分，尽量做到与框架及框架语法无关（即抽取为原生语言逻辑）
* 视图代码与交互代码由于需要使用框架提供的特性，所以可以与框架耦合
* 在业务、数据、服务、工具库层与视图层之间新加一层适配层，方便框架迁移    



## 4. 层层分析

### 1. 界面展示层

* 由于界面展示层是十分多变的，所以这一层不需要考虑跨时期复用，直接与相关框架进行绑定就可以，如果需要迁移框架或设备，直接重写该层。
* 

### 1. 数据层

* 一次请求可以分解为以下元组件
  * 地址：即后端接口地址，可能会变，但变动频次非常低
  * 参数：即接口需要的参数，可能会变，但变动频次很低
  * 方法：即Get或Post，基本不会变，且很多接口两种方法都支持
  * 请求头：不同接口可能不同
  * 响应格式：可以是JSON/BLOB/BINARY等
  * 超时时间： 请求超时可取消
  * 成功后的回调：回调中可能由两类操作：业务操作/界面操作
  * 失败后的回调：回调中可能由两类操作：业务操作/界面操作

* 现在基本不会再使用原生js去写XHR请求了，前有jqery.ajax，后有axios 和 fetch等请求库，那么如何隔离不同请求库对数据层的影响也就至关重要。

* 如果技术不退步的话，基本上不管什么请求库，现在返回的都是一个promise对象了

* 那么一个典型的请求流程可能是这样：

  ```javascript
  
  
  // /api/demo
  
  export function getDemoList(params) {
    const url = urls['demo/list'];
    return request(url, params, 'post', config);
  }
  
  
  ```

  

